# Android八股文 - Chip - 2023



## 一、Activity



### 1.什么是activity？

- 四大组件之一

- Context 子类
- 实现了 window.callback 和 keyevent.callback ，可以处理窗体与用户交互的事件
- 开发常用：FragmentActivitiy、TabAcitivty、ListActivity

### 2.请描述Activity生命周期

- Activity从创建到销毁有多种状态，从一种状态到另一种状态时会激发相应的回调方法。

包括：onCreate创建 onStart可见 onResume焦点 onPause不可编辑 onStop不可见 onDestory销毁

这些方法两两对应。

### 3.Activity生命周期  

### 4.保存 Activity 的状态或者（ Activiy 重启怎么保存数据？）

- Activity 的状态通常情况下系统会自动保存的，只有当我们需要保存额外的数据时才需要使用到这样的功能。

- 通常：调用onPause()和onStop()方法后的activity 实例仍然存在于内存中，activity 的所有信息和状态数据不会消失，当 activity 重新回到前台之后，所有的改变都会得到保留。

- 内存不足时：调用onPause()和onStop()方法后的activity 可能会被系统摧毁，activity 重新回到前台, 之前所作的改变就会消失。
- 解决方法：可以覆写 onSaveInstanceState()方法，他接受一个 Bundle 类型的参数, 开发者可以将状态数据存储到这个 Bundle 对象中，在 onPause()或 onStop()方法之前调用 onSaveInstanceState()。重新启动这个 activity 而调用它的onCreate()方法时, 上述的Bundle 对象会作为实参传递给 onCreate()方法，开发者可以从 Bundle 对象中取出保存的数据, 然后利用这些数据将 activity 恢复到被摧毁之前的状态。

- 注意：用户按下 BACK 键退出 activity 时, 用户显然想要关闭这个 activity，onSaveInstanceState()方法不会被调用。

```java
@Override
protected void onSaveInstanceState(Bundle outState) {
// TODO Auto-generated method stub
super.onSaveInstanceState(outState);
}
```

### 5、 两个 Activity 之间跳转时必然会执行的是哪几个方法？

- 当Activity **A**跳转到**B**时，**A**会调用onPause()方法，然后**B**调用onCreate(),onStart(),onResume()方法。
- 如果**B**覆盖了窗体，**A**会调用onStop()方法；如果**B**是透明的或者是个对话框，**A**不会调用onStop()方法。

### 6、 横竖屏切换时Activity 的生命周期（★★★★）

activity 在配置更改时（如屏幕方向、键盘可用性、语言、屏幕大小等）和**清单文件里的配置**有关系。

- 不设置 Activity 的 android:configChanges 时，切屏会重新调用各个生命周期默认首先销毁当前 activity,然后重新加载。
- 当 android:configChanges 属性设置了某些选项时，每次发生对应的更改时，Android 系统不再销毁并重新创建该 activity，而是会调用该 activity 的 onConfigurationChanged() 方法。因此，在该方法中，开发者需要自行处理相关的逻辑以适应新的配置状态。

### 7、 如何将一个 Activity 设置成窗口的样式

将 Activity 配置如下属性即可。

android:theme="@android:style/Theme.Dialog"

### 8、 如何退出 Activity ？ 如何安全退出已调用多个Activity 的 Application？（★★★★）


1. 用户：退出一个 Activity 只需按返回键

   开发者：调用finish()

2. 递归退出
   在打开新的 Activity 时使用 startActivityForResult，然后自己加标志，在onActivityResult 中处理，递归关闭。

   

3. 记录打开的 Activity：

   维护一个Activity List记录打开的每一个Activity，在需要退出时，循环finish每一个 Activity 即可。

```java
List<Activity> lists ;// 在 application 全局的变量里面
lists = new ArrayList<Activity>();
lists.add(this);
for(Activity activity: lists){
	activity.finish();
}
lists.remove(this);
```

4. 发送特定广播：

   在需要结束应用时，发送一个特定的广播，每个 Activity 收到广播后，关闭即可。

   ```java
   //给某个 activity 注册接受接受广播的意图
   registerReceiver(receiver, filter)
   //如果接受到 关闭 activity 的广播 就调用 finish() 方法 把当前的 activity finish()掉
   ```

5. 通过 intent 的 flag 来实现

```java
intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
```

- 激活一个新的 activity，此时会把该任务栈中这个 Activity 上面的所有Activity 清除。

- 相当于给 Activity 配置的启动模式为 SingleTop。

### 9、 Activity 的 四 种 启 动 模 式 ， singletop 和singletask 区别是什么？一般书签的使用模式是 singletop ，那为什么不使用  singletask ?

- singleTop 跟 standard 模式比较类似。**唯一的区别**就是：

  当跳转的对象是位于栈顶的 activity（应该可以理解为用户眼前所 看到的 activity）时，程序**将不会生成一个新的activity 实例**，而是直接跳到现存于栈顶的那个 activity 实例。拿上面的例子来说，当 Act1 为 singleTop 模式时，执行跳转后栈里面依旧只有一个实例，如果现在按返回键程序将直接退出。

- singleTask 模式和 singleInstance 模式都是只创建一个实例的。在这种模式下，若栈里面已经有这个实例，无论跳转的对象是不是位于栈顶的 activity，程序都不会生成一个新的实例。指定singleInstance模式的Activity会启用一个新的返回栈来管理这个Activity。

- 在一般情况下，使用 singleTop 模式是比较合适的，因为使用这种模式可以避免很多意外情况，相比之下，使用 singleTask 模式需要考虑更多的因素，因此并不是所有的场景都适用。比如：使用 singleTask 模式时，当在一个 task 中已经存在目标 Activity 的实例时，操作返回时栈顶会将中间的所有 Activity 移除，从而可能导致一系列操作后得到的返回结果不一致，需要进行特殊处理。

### 10、Android 中的 Context, Activity，Appliction 有什么区别？（★★）

- 相同点：Activity和Application都是Context的子类。

- Context指上下文的意思，实际应用中起**管理上下文环境中各个参数各变量的作用**，方便我们可以简单的访问到各种资源。

- 不同点：维护的生命周期不同：

  Context维护的是当前Activity的生命周期，Application维护的是整个项目的生命周期。

- 使用 context 的时候，要防止内存泄露，需要注意一下几个方面：

  1. 不要让生命周期长的对象引用 activity context，即保证引用 activity 的对象要与 activity 本身生命周期是一样的。
  2. 对于生命周期长的对象，可以使用 application，context。
  3. 避免非静态的内部类，**尽量使用静态类**，避免生命周期问题，注意内部类对外部对象引用导致的生命周期变化。

### 11、两个Activity 之间传递数据，除了 intent，广播接收者，content provider 还有那些方法？

1. static静态数据，public static 成员变量
2. 利用外部存储的传输， 例如：File 文件存储、SharedPreferences 轻量级的存储类、Sqlite 数据库

### 12、Context 是 什 么 ？ ， 一 个 应 用 有 多 少 个 Context(2020.5.15）（★★）

1. 它描述的是一个应用程序环境的信息，即上下文，起**管理上下文环境中各个参数各变量的作用**，方便我们可以简单的访问到各种资源。
2. 该类是一个抽象(abstract class)类，Android 提供了该抽象类的具体实现类（ContextIml）。
3. 通过它我们可以获取应用程序的资源和类，也包括一些应用级别操作， 例如：启动一个 Activity，发送广播，接受 Intent，信息等。
4. **一个应用 Context 数量**=**Activity 个数** + **service 个数** + 1 个

### 13.activity 之间还有 activity 和 service 之间如何传值，可以传图片吗？



- Activity 之间传值：

  使用Intent：通过 Intent 对象的各种 putExtra 方法来进行传递。在第二个 Activity 对象中，可以通过 getIntent() 方法来得到跳转到这个 Activity 的 Intent 对象，然后通过 Intent 对象的各种 getXXExtra 方法来得到我们的传过来的值。

- Activity 和 Service 之间传值：

  1. 通过 startService（intent）使用Intent传值。

     此时需要在清单文件中注册这个Service

  ```xml
  <service Android:enabled="true" android:name=".Service">
  </service>
  ```

  2. Service 可以从 public int onStartCommand(Intent intent, int flags, int startId)中取出从 activity 中传过来的值。intent.getExtra()获得 bundle 对象， 可从中取值。

  3. Activity 也可以用 bindService(intent, conn,BIND_AUTO_CREATE);传值，把要传的值绑定在 intent 里，在 service 的 public IBinder onBind(Intent intent) 方法里取得 intent 。
  4. 可以在 reseiver 里面注册一个广播，在 activity 里sendbroadcast（intent）传值。

- 可以传递图片：用 Intent 把**图片的地址**或者把**图片对象**用 Intent 传过去，用**bitmap** 对象。

  

## 二、Service

### 1.Service是否在main thread中执行，Service里面是否能执行耗时操作？（★★）

- 若未显式声明Service所运行的进程，Service和Activity是运行在dangqianapp所在进程的main thread（UI主线程）里面。

- 不可执行耗时操作，如：网络请求、拷贝数据库、大文件

- 可以在清单文件中配置Service执行所在的进程，让Service在另外的进程中执行

  ```xml
  <service
  	android:name="com.baidu.location.f" 
  	android:enabled="true" 
  	android:process=":remote" >
  </service>
  ```

### 2.Activity怎么和Service绑定，怎么在Activity中启动自己对应的Service？

- Activity通过bindService(Intent service,ServiceConnection conn,int flags)同Service进行绑定，当绑定成功的时候Service会将代理对象通过回调的形式传给conn，就可以拿到Service提供的服务代理对象。
- 可以通过startService和bindService启动Service。想获取Service的服务对象，需要bindService()方法，如音乐播放器或第三方支付。
- 如果仅仅为了开启一个后台任务可以使用startService()方法。

### 3.描述Service的生命周期（★★★）

Service有非绑定模式、绑定模式、这两种的混合方式。不同使用方法生命周期不同。

- 非绑定模式：第一次调用startService的时候，执行方法依次为：onCreate()、onStartCommand()，当Service关闭的时候调用onDestory()方法。
- 绑定模式：第一次调用bindService()的时候，执行方法依次为：onCreate()、onBind()，解除绑定的时候会执行 onUnbind()、onDestory()。

> 上面的两种生命周期是在相对单纯的模式下的情形。我们在开发的过程中还必须注意 Service 实例只会有一个，也就是说如果当前要启动的 Service 已经存在了那么就不会再次创建该 Service 当然也不会调用 onCreate（）方法。
>



> 一个 Service 可以被多个客户进行绑定，只有所有的绑定对象都执行了
> onBind（）方法后该 Service 才会销毁，不过如果有一个客户执行了 onStart() 方法，那么这个时候如果所有的 bind 客户都执行了 unBind()该 Service 也不会销毁。



<img src="https://cdn.jsdelivr.net/gh/ChengYang1998/blogImage@main/PicGo/image-20230322103750747.png" alt="image-20230322103750747" style="zoom:67%;" />

### 4.什么是IntentService？有何优点？（★★★）

> 我们通常只会使用 Service，可能 IntentService 对大部分同学来说都是第一次听说。那么看了下面的介绍相信你就不再陌生了。如果你还是不了解那么在面试的时候你就坦诚说没用过或者不了解等。并不是所有的问题都需要回答上来的。

1. IntentService简介

- IntentService是Service的子类，比普通Service增加了额外的功能
- Service 本身存在两个问题：
  1. Service 不会专门启动一条单独的进程，Service 与它所在应用位于同一个进程中
  2. Service 也不是专门一条新线程，因此不应该在 Service 中直接处理耗时的任务

2. IntentService特征

   - 会创建独立的worker线程来处理**所有的Intent请求**
   - 会创建独立的worker线程来处理**onHandleIntent()**方法实现的代码，无需处理多线程问题
   - 所有请求处理完成后，IntentService 会自动停止，无需调用 stopSelf()方法停止 Service
   - 为 Service 的 onBind()提供默认实现，返回 null
   - 为 Service 的 onStartCommand() 提供默认实现，将请求 Intent 添加到队列中

3. 使用 IntentService

   













