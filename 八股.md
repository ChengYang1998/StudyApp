# Android八股文 - Chip - 2023



# 第一章：Android 基础

## 一、Activity



### 1.什么是activity？

- 四大组件之一

- Context 子类
- 实现了 window.callback 和 keyevent.callback ，可以处理窗体与用户交互的事件
- 开发常用：FragmentActivitiy、TabAcitivty、ListActivity

### 2.请描述Activity生命周期

- Activity从创建到销毁有多种状态，从一种状态到另一种状态时会激发相应的回调方法。

包括：onCreate创建 onStart可见 onResume焦点 onPause不可编辑 onStop不可见 onDestory销毁

这些方法两两对应。

### 3.Activity生命周期

### 4.保存 Activity 的状态或者（ Activiy 重启怎么保存数据？）

- Activity 的状态通常情况下系统会自动保存的，只有当我们需要保存额外的数据时才需要使用到这样的功能。

- 通常：调用`onPause()`和`onStop()`方法后的activity 实例仍然存在于内存中，activity 的所有信息和状态数据不会消失，当 activity 重新回到前台之后，所有的改变都会得到保留。

- 内存不足时：调用`onPause()`和`onStop()`方法后的activity 可能会被系统摧毁，activity 重新回到前台, 之前所作的改变就会消失。
- 解决方法：可以覆写 `onSaveInstanceState()`方法，他接受一个 Bundle 类型的参数, 开发者可以将状态数据存储到这个 Bundle 对象中，在 onPause()或 onStop()方法之前调用 `onSaveInstanceState()`。重新启动这个 activity 而调用它的`onCreate()`方法时, 上述的Bundle 对象会作为实参传递给 `onCreate()`方法，开发者可以从 Bundle 对象中取出保存的数据, 然后利用这些数据将 activity 恢复到被摧毁之前的状态。

- 注意：用户按下 BACK 键退出 activity 时, 用户显然想要关闭这个 activity，`onSaveInstanceState()`方法不会被调用。

```java
@Override
protected void onSaveInstanceState(Bundle outState) {
// TODO Auto-generated method stub
super.onSaveInstanceState(outState);
}
```

### 5、 两个 Activity 之间跳转时必然会执行的是哪几个方法？

- 当Activity **A**跳转到**B**时，**A**会调用onPause()方法，然后**B**调用onCreate(),onStart(),onResume()方法。
- 如果**B**覆盖了窗体，**A**会调用onStop()方法；如果**B**是透明的或者是个对话框，**A**不会调用onStop()方法。

### 6、 横竖屏切换时Activity 的生命周期（★★★★）

activity 在配置更改时（如屏幕方向、键盘可用性、语言、屏幕大小等）和**清单文件里的配置**有关系。

- 不设置 Activity 的 android:configChanges 时，切屏会重新调用各个生命周期默认首先销毁当前 activity,然后重新加载。
- 当 android:configChanges 属性设置了某些选项时，每次发生对应的更改时，Android 系统不再销毁并重新创建该 activity，而是会调用该 activity 的 `onConfigurationChanged()` 方法。因此，在该方法中，开发者需要自行处理相关的逻辑以适应新的配置状态。

### 7、 如何将一个 Activity 设置成窗口的样式

将 Activity 配置如下属性即可。

android:theme="@android:style/Theme.Dialog"

### 8、 如何退出 Activity ？ 如何安全退出已调用多个Activity 的 Application？（★★★★）


1. 用户：退出一个 Activity 只需按返回键

   开发者：调用`finish()`

2. 递归退出
   在打开新的 Activity 时使用 startActivityForResult，然后自己加标志，在onActivityResult 中处理，递归关闭。

   

3. 记录打开的 Activity：

   维护一个Activity List记录打开的每一个Activity，在需要退出时，循环finish每一个 Activity 即可。

```java
List<Activity> lists ;// 在 application 全局的变量里面
lists = new ArrayList<Activity>();
lists.add(this);
for(Activity activity: lists){
	activity.finish();
}
lists.remove(this);
```

4. 发送特定广播：

   在需要结束应用时，发送一个特定的广播，每个 Activity 收到广播后，关闭即可。

   ```java
   //给某个 activity 注册接受接受广播的意图
   registerReceiver(receiver, filter)
   //如果接受到 关闭 activity 的广播 就调用 finish() 方法 把当前的 activity finish()掉
   ```

5. 通过 intent 的 flag 来实现

```java
intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
```

- 激活一个新的 activity，此时会把该任务栈中这个 Activity 上面的所有Activity 清除。

- 相当于给 Activity 配置的启动模式为 SingleTop。

### 9、 Activity 的 四 种 启 动 模 式 ， singletop 和singletask 区别是什么？一般书签的使用模式是 singletop ，那为什么不使用  singletask ?

- singleTop 跟 standard 模式比较类似。**唯一的区别**就是：

  当跳转的对象是位于栈顶的 activity（应该可以理解为用户眼前所 看到的 activity）时，程序**将不会生成一个新的activity 实例**，而是直接跳到现存于栈顶的那个 activity 实例。拿上面的例子来说，当 Act1 为 singleTop 模式时，执行跳转后栈里面依旧只有一个实例，如果现在按返回键程序将直接退出。

- singleTask 模式和 singleInstance 模式都是只创建一个实例的。在这种模式下，若栈里面已经有这个实例，无论跳转的对象是不是位于栈顶的 activity，程序都不会生成一个新的实例。指定singleInstance模式的Activity会启用一个新的返回栈来管理这个Activity。

- 在一般情况下，使用 singleTop 模式是比较合适的，因为使用这种模式可以避免很多意外情况，相比之下，使用 singleTask 模式需要考虑更多的因素，因此并不是所有的场景都适用。比如：使用 singleTask 模式时，当在一个 task 中已经存在目标 Activity 的实例时，操作返回时栈顶会将中间的所有 Activity 移除，从而可能导致一系列操作后得到的返回结果不一致，需要进行特殊处理。

### 10、Android 中的 Context, Activity，Appliction 有什么区别？（★★）

- 相同点：Activity和Application都是Context的子类。

- Context指上下文的意思，实际应用中起**管理上下文环境中各个参数各变量的作用**，方便我们可以简单的访问到各种资源。

- 不同点：维护的生命周期不同：

  Context维护的是当前Activity的生命周期，Application维护的是整个项目的生命周期。

- 使用 context 的时候，要防止内存泄露，需要注意一下几个方面：

  1. 不要让生命周期长的对象引用 activity context，即保证引用 activity 的对象要与 activity 本身生命周期是一样的。
  2. 对于生命周期长的对象，可以使用 application，context。
  3. 避免非静态的内部类，**尽量使用静态类**，避免生命周期问题，注意内部类对外部对象引用导致的生命周期变化。

### 11、两个Activity 之间传递数据，除了 intent，广播接收者，content provider 还有那些方法？

1. static静态数据，public static 成员变量
2. 利用外部存储的传输， 例如：File 文件存储、SharedPreferences 轻量级的存储类、Sqlite 数据库

### 12、Context 是 什 么 ？ ， 一 个 应 用 有 多 少 个 Context(2020.5.15）（★★）

1. 它描述的是一个应用程序环境的信息，即上下文，起**管理上下文环境中各个参数各变量的作用**，方便我们可以简单的访问到各种资源。
2. 该类是一个抽象(abstract class)类，Android 提供了该抽象类的具体实现类（ContextIml）。
3. 通过它我们可以获取应用程序的资源和类，也包括一些应用级别操作， 例如：启动一个 Activity，发送广播，接受 Intent，信息等。
4. **一个应用 Context 数量**=**Activity 个数** + **service 个数** + 1 个

### 13.activity 之间还有 activity 和 service 之间如何传值，可以传图片吗？



- Activity 之间传值：

  使用Intent：通过 Intent 对象的各种 putExtra 方法来进行传递。在第二个 Activity 对象中，可以通过 `getIntent()` 方法来得到跳转到这个 Activity 的 Intent 对象，然后通过 Intent 对象的各种 getXXExtra 方法来得到我们的传过来的值。

- Activity 和 Service 之间传值：

  1. 通过 `startService（intent）`使用Intent传值。

     此时需要在清单文件中注册这个Service

  ```xml
  <service Android:enabled="true" android:name=".Service">
  </service>
  ```

  2. Service 可以从 `public int onStartCommand(Intent intent, int flags, int startId)`中取出从 activity 中传过来的值。`intent.getExtra()`获得 bundle 对象， 可从中取值。

  3. Activity 也可以用 bindService(intent, conn,BIND_AUTO_CREATE);传值，把要传的值绑定在 intent 里，在 service 的 `public IBinder onBind(Intent intent)` 方法里取得 intent 。
  4. 可以在 reseiver 里面注册一个广播，在 activity 里`sendbroadcast(intent)`传值。

- 可以传递图片：用 Intent 把**图片的地址**或者把**图片对象**用 Intent 传过去，用**bitmap** 对象。

  

## 二、Service

### 1.Service是否在main thread中执行，Service里面是否能执行耗时操作？（★★）

- 若未显式声明Service所运行的进程，Service和Activity是运行在dangqianapp所在进程的main thread（UI主线程）里面。

    不可执行耗时操作，如：网络请求、拷贝数据库、大文件

- 可以在清单文件中配置Service执行所在的进程，让Service在另外的进程中执行

  ```xml
  <service
  	android:name="com.baidu.location.f" 
  	android:enabled="true" 
  	android:process=":remote" >
  </service>
  ```

### 2.Activity怎么和Service绑定，怎么在Activity中启动自己对应的Service？

- Activity通过`bindService(Intent service,ServiceConnection conn,int flags)`同Service进行绑定，当绑定成功的时候Service会将代理对象通过回调的形式传给conn，就可以拿到Service提供的服务代理对象。
- 可以通过startService和bindService启动Service。想获取Service的服务对象，需要`bindService()`方法，如音乐播放器或第三方支付。
- 如果仅仅为了开启一个后台任务可以使用startService()方法。

### 3.描述Service的生命周期（★★★）

Service有非绑定模式、绑定模式、这两种的混合方式。不同使用方法生命周期不同。

- 非绑定模式：第一次调用startService的时候，执行方法依次为：`onCreate()`、`onStartCommand()`，当Service关闭的时候调用`onDestory()`方法。
- 绑定模式：第一次调用bindService()的时候，执行方法依次为：`onCreate()`、`onBind()`，解除绑定的时候会执行 `onUnbind()`、`onDestory()`。

> 上面的两种生命周期是在相对单纯的模式下的情形。我们在开发的过程中还必须注意 Service 实例只会有一个，也就是说如果当前要启动的 Service 已经存在了那么就不会再次创建该 Service 当然也不会调用 onCreate（）方法。
>



> 一个 Service 可以被多个客户进行绑定，只有所有的绑定对象都执行了
> onBind（）方法后该 Service 才会销毁，不过如果有一个客户执行了 onStart() 方法，那么这个时候如果所有的 bind 客户都执行了 unBind()该 Service 也不会销毁。



<img src="https://cdn.jsdelivr.net/gh/ChengYang1998/blogImage@main/PicGo/image-20230322103750747.png" alt="image-20230322103750747" style="zoom:67%;" />

### 4.什么是IntentService？有何优点？（★★★）

> 我们通常只会使用 Service，可能 IntentService 对大部分同学来说都是第一次听说。那么看了下面的介绍相信你就不再陌生了。如果你还是不了解那么在面试的时候你就坦诚说没用过或者不了解等。并不是所有的问题都需要回答上来的。

1. IntentService简介

   - IntentService是Service的子类，比普通Service增加了额外的功能

   - Service 本身存在两个问题：
     1. Service 不会专门启动一条单独的进程，Service 与它所在应用位于同一个进程中
     2. Service 也不是专门一条新线程，因此不应该在 Service 中直接处理耗时的任务


2. IntentService特征

   - 会创建独立的worker线程来处理**所有的Intent请求**
   
   - 会创建独立的worker线程来处理`onHandleIntent()`方法实现的代码，无需处理多线程问题
   
   - 所有请求处理完成后，IntentService 会自动停止，无需调用 stopSelf()方法停止 Service
   
   - 为 Service 的 `onBind()`提供默认实现，返回 null
   
   - 为 Service 的 `onStartCommand()` 提供默认实现，将请求 Intent 添加到队列中
   
3. 使用 IntentService

   IntentService使用例。

   - MainActivity.java:

   ```java
   public void click(View view) {
   	Intent intent = new Intent(this, MyIntentService.class); 					intent.putExtra("start", "MyIntentService"); 
       startService(intent);
   }
   ```
   -   MyIntentService.java

   ```java
   public class MyIntentService extends IntentService {
   	private String ex = "";
       private Handler mHandler = new Handler() {
           public void handleMessage(android.os.Message msg) {
               Toast.makeText(MyIntentService.this, "-e " + ex,Toast.LENGTH_LONG).show();
           }
       };
       
       public MyIntentService() { 
           super("MyIntentService");
       }
   
    
       @Override
       public int onStartCommand(Intent intent, int flags, int startId) { 
           ex = intent.getStringExtra("start");
           return super.onStartCommand(intent, flags, startId);
       }
   
      /**
   		* 模拟执行耗时任务
   		* 该方法是在子线程中执行的，因此需要用到 handler 跟主线程进行通信
   		*/
       @Override
       protected void onHandleIntent(Intent intent) {
        
           try {
               Thread.sleep(1000);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
           mHandler.sendEmptyMessage(0);
           try {
               Thread.sleep(1000);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
       }
   }
   ```


### 5.Activity、Intent、Service关系

- Activity、Service是四大组件之一，都是 Context 类的子类ContextWrapper 的子类。
- Activity 负责用户界面的显示和交互，Service 负责后台任务的处理。
- Activity 和 Service 之间可以通过 Intent 传递数据。

### 6.Service 和Activity 在同一个线程吗（★）

未显式声明的情况下都在UI线程。

### 7.Service 里面可以弹吐司么（★）

可以的。弹吐司有个条件就是得有一个 Context 上下文，而 Service 本身就是 Context 的子类，因此在 Service 里面弹吐司是完全可以的。比如我们在Service 中完成下载任务后可以弹一个吐司通知用户。

### 8.什么是 Service 以及描述下它的生命周期。Service 有哪些启动方法，有什么区别，怎样停用Service？（★★★）

在Service 的生命周期中，被回调的方法比 Activity 少一些，只有 onCreate, onStart, onDestroy,
onBind 和 onUnbind。
通常有两种方式启动一个 Service,他们对 Service 生命周期的影响是不一样的。

1. 通过 startService
    Service 会经历 onCreate 到 onStart，然后处于运行状态，stopService 的时候调用 onDestroy 方法。
    如果是调用者自己直接退出而没有调用 stopService 的话，Service 会一直在后台运行。
2. 通过 bindService
    Service会运行onCreate，然后是调用onBind，这个时候调用者和Service绑定在一起。调用者退出了，Srevice 就会调用 onUnbind->onDestroyed 方法。

所谓绑定在一起就共存亡了。调用者也可以通过调用 unbindService 方法来停止服务，这时候 Srevice 就会调用 onUnbind -> onDestroyed 方法。

如果这几个方法交织在一起的话，会出现什么情况？

- 一个原则是 Service 的 **onCreate 的方法只会被调用一次**，就是你无论多少次的startService 又 bindService，Service 只被创建一次。
- 如果先是 bindService  了，那么 start 的时候就直接运行 Service 的 onStart 方法， 如果先是 startService ，那么 bind 的时候就直接运行 onBind 方法。
- 如果 service 运行期间调用了 bindService，这时候再调用 stopService 的话，service 是不会调用 onDestroy 方法的，service 就 stop 不掉了，只能调用UnbindService, service 就会被销毁
- 如果一个 service 通过 startService 被 start 之后，多次调用 startService的话，service 会多次调用 onStart 方法。多次调用 stopService 的话，service 只会调用一次 onDestroyed 方法。
- 如果一个 service 通过 bindService 被 start 之后，多次调用 bindService 的话，service 只会调用一次 onBind 方法。**多次调用 unbindService 的话会抛出异常**。

### 9.在Service的生命周期方法onstartCommand()可不可以执行网络操作？如何在Service中执行网络操作？

可以在 `onStartCommand()` 方法中执行网络操作，但需要注意一些细节。

在执行网络操作时，需要在一个独立的线程中进行，以避免在主线程中阻塞。因此，在 `onStartCommand()` 中启动一个新的线程，并在该线程中执行网络操作是一个好的选择。

以下是一个示例，说明如何在 Service 中执行网络操作：

```java
public class MyService extends Service {
    private Thread mThread;

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        mThread = new Thread(() -> {
            // 在这里执行网络操作
            // ...

            // 在完成操作后，调用stopSelf()以停止服务
            stopSelf();
        });
        mThread.start();
        return START_NOT_STICKY;
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        if (mThread != null) {
            mThread.interrupt();
        }
    }

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }
}

```

在上面的示例中，我们在 `onStartCommand()` 方法中创建一个新的线程，并在其中执行网络操作。在完成操作后，我们调用 `stopSelf()` 方法以停止服务。在 `onDestroy()` 方法中，我们中断线程，以确保线程在服务销毁时被正确地终止。



## 三、Broadcast Receiver

### 1.请描述一下 BroadcastReceiver（★★）

- 定义：BroadcastReceiver是Android应用程序中的一个组件，用于接收系统或app发送的广播消息，并根据需要执行相应的操作。广播消息是一种用于应用程序间通信和事件传递的机制，可以在应用程序内部、跨应用程序和系统级别上发送和接收广播消息。
- BroadcastReceiver实现了一个特定的Java接口，并在应用程序的清单文件中注册，并且声明它所匹配的广播消息类型。当一个匹配的广播消息被发送时，系统将自动调用BroadcastReceiver的`onReceive()`方法，其中包含接收到的广播消息的信息。开发人员可以根据需要在`onReceive()`方法中编写自己的代码，例如启动服务、更新UI等等。
- 广播分两种：**有序广播**和**无序广播**。
- 内部通信实现机制：通过 Android 系统的 **Binder** 机制实现通信。
- 无序广播：完全异步，逻辑上可以被任何广播接收者接收到。优点是效率较高。缺点是一个接收者不能将处理结果传递给下一个接收者，并无法终止广播 intent 的传播。
- 有序广播：按照被接收者的优先级顺序，在被接收者中依次传播。比如有三个广播接收者 A，B，C，优先级是 A > B > C。那这个消息先传给 A，再传给 B，最后传给 C。每个接收者有权终止广播，比如 B 终止广播，C 就无法接收到。此外 A 接收到广播后可以对结果对象进行操作，当广播传给 B 时，B 可以从结果对象中取得 A 存入的数据。
- 通过 `Context.sendOrderedBroadcast(intent, receiverPermission,resultReceiver, scheduler, initialCode, initialData, initialExtras)`可以指定 resultReceiver 广播接收者，这个接收者认为是最终接收者。通常情况下如果比他优先级更高的接收者如果没有终止广播，那么他的`onReceive()`会被**执行两次**。第一次是正常的**按照优先级顺序执行**，第二次是**作为最终接收者接收**（如果比他优先级高的接收者终止了广播，那么他依然能接收到广播）。
- 例如：在我们的项目中经常使用广播接收者接收系统通知，比如开机启动、sd 挂载、低电量、外播电话、锁屏，如果我们做的是播放器，那么监听到用户锁屏后我们应该将我们的播放暂停。

### 2.在 manifest 和代码中如何注册和使用 BroadcastReceiver

- 静态注册：

    - 在清单文件中注册广播接收者称为静态注册

    - 静态注册的广播接收者只要 app 在系统中运行则一直可以接收到广播消息

        ```xml
        <application
                     ...>
            <receiver android:name=".MyBroadcastReceiver"
                      android:exported="true"
                      android:enabled="true">
                <intent-filter>
                    <action android:name="android.intent.action.BOOT_COMPLETED" />
                </intent-filter>
            </receiver>
        </application>
        ```
        
        在上面的示例中，我们将 `MyBroadcastReceiver` 注册为接收系统启动完成广播的接收器。我们在 `<intent-filter>` 元素中使用了 `<action>` 元素，以指定我们要接收的广播消息类型。
        
        注意，必须在应用程序的清单文件中声明 `BroadcastReceiver`，以便操作系统可以找到它并将广播消息发送到它。

-   动态注册：

    -   在代码中注册称为动态注册

    -   动态注册的广播接收者当注册的 Activity 或者 Service 销毁了那么就接收不到广播

        ```java
        MyBroadcastReceiver myReceiver = new MyBroadcastReceiver();
        IntentFilter filter = new IntentFilter();
        filter.addAction(Intent.ACTION_POWER_CONNECTED);
        filter.addAction(Intent.ACTION_POWER_DISCONNECTED);
        registerReceiver(myReceiver, filter);
        ```
        
        在上面的示例中，我们使用 `registerReceiver()` 方法动态注册了 `MyBroadcastReceiver` 接收器，它将接收电源连接和断开广播消息。
    
    -   要注销接收器，请使用 `unregisterReceiver()` 方法：
    
        ```java
        unregisterReceiver(myReceiver);
        ```
    
-   发送广播消息

    在发送广播消息时，你需要使用 `Intent` 对象来描述要发送的消息类型。例如，要发送一个自定义的广播消息，你可以编写以下代码：

	```java
Intent intent = new Intent(); 
intent.setAction("com.example.myapp.MY_ACTION");
intent.putExtra("key", "value"); 
sendBroadcast(intent);
	```

    在上面的示例中，我们创建了一个新的 `Intent`，并设置了 `action` 和 `extra` 字段来描述我们要发送的广播消息类型和数据。

-   接收广播消息

	当你的应用程序注册了一个 `BroadcastReceiver` 并且符合该广播消息的条件时，系统将会调用 `BroadcastReceiver` 的 `onReceive()` 方法，让你的应用程序可以响应这个广播消息。
	
	
	
	在 `onReceive()` 方法中，你可以编写你的应用程序响应广播消息的逻辑。例如，如果你的应用程序需要在接收到 `ACTION_POWER_CONNECTED` 广播消息时更新用户界面，则可以编写以下代码：

	```java
	public class MyBroadcastReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        if (action.equals(Intent.ACTION_POWER_CONNECTED)) {
            // 更新用户界面
        }
    }
	}
	```

	在上面的示例中，我们在 `onReceive()` 方法中检查接收到的广播消息类型是否是 `ACTION_POWER_CONNECTED`，如果是，则更新用户界面。

	>   注意，如果你需要在 `BroadcastReceiver` 中执行任何耗时操作，例如网络请求或文件 I/O 操作，请务必将其放在一个单独的线程中，以避免阻塞 UI 线程。

### 3.BroadCastReceiver 的生命周期

它的生命周期方法分别是：

1.  onReceive(): BroadcastReceiver 的核心方法，在接收到广播时被调用。在这个方法中，可以对接收到的广播进行处理。
2.  onAbortBroadcast(): 在接收到广播后，如果需要终止广播的传递，可以调用这个方法。
3.  onReceive(Context context, Intent intent): 这个方法是 BroadcastReceiver 的重载方法，它接收两个参数，第一个参数是 Context，第二个参数是 Intent。在这个方法中，可以通过 Intent 获取广播的信息，并对广播进行处理。
4.  onEnabled(Context context, Intent intent): 当 BroadcastReceiver 被系统启用时调用。
5.  onDisabled(Context context, Intent intent): 当 BroadcastReceiver 被系统禁用时调用。
6.  onRegister(Context context, Intent intent): 当 BroadcastReceiver 被注册时调用。
7.  onUnregister(Context context, Intent intent): 当 BroadcastReceiver 被注销时调用。

**注意**：

1.   广播接收者的生命周期非常短暂的， 在接收到广播的时候创建，onReceive()方法结束之后销毁。
2.   广播接收者中不要做一些耗时的工作， 否则会弹出 Application No Response 错误对话框。
3.   最好也不要在广播接收者中创建子线程做耗时的工作，因为广播接收者被销毁后进程就成为了空进程，很容易被系统杀掉。
4.   耗时的较长的工作最好放在服务中完成。

-   Android中引入广播机制的用意

    Android 引入广播机制的主要目的是为了简化 Android 应用程序之间的通信，以及在同一个应用程序内部的不同组件之间的通信。广播机制也提供了一种轻量级的、异步的、松散耦合的通信方式。
    通过广播机制，一个应用程序可以向所有已注册该广播的应用程序、系统、设备和其他组件发送消息。这使得多个组件可以在不使用复杂的应用程序之间的绑定和纷繁复杂的消息传递协议的情况下共享相同的事件。
    例如，当设备的电池电量发生变化时，系统会发送一个广播消息。所有已注册了该广播的应用程序都将接收到此消息。这使得应用程序可以根据电池电量的变化来调整其行为。
    总之，Android 广播机制简化了 Android 应用程序之间的通信，使得应用程序可以更容易地实现复杂的功能。

    1.   Android 的四大组件本质上就是为了实现移动或者说嵌入式设备上的 MVC 架构，它们之间有时候是一种相互依存的关系，有时候又是一种补充关系，引入广播机制可以方便几大组件的信息和数据交互。
    2.   程序间互通消息(例如在自己的应用程序内监听系统来电)
    3.   效率上(参考 UDP 的广播协议在局域网的方便性)
    4.   设计模式上(反转控制的一种应用，类似监听者模式)



## 四、ContentProvider

### 1.请介绍下 ContentProvider 是如何实现数据共享的（★★★）

-   在 Android 中如果想将自己应用的数据（一般多为数据库中的数据）提供给第三发应用，那么我们只能通过 ContentProvider 来实现了。

-   ContentProvider 是应用程序之间共享数据的接口。使用的时候首先自定义一个类继承 ContentProvider，然后覆写 query、insert、update、delete 等方法。

-   必须在 AndroidManifest 文件中进行注册。

-   把自己的数据通过 uri 的形式共享出去，android 系统下 不同程序 数据默认是不能共享访问，需要去实现一个类去继承 ContentProvider

    ```java
    public class PersonContentProvider extends ContentProvider{
        public boolean onCreate(){
        }
        query(Uri, String[], String, String[], String)
            insert(Uri, ContentValues);
            update(Uri, ContentValues, String, String[]);
            delete(Uri, String, String[]);
    }
    ```

    ```xml
    <provider android:exported="true"
              android:name="com.itheima.contenProvider.provider.PersonContentPro vider"
              android:authorities="com.itheima.person"  />
    ```

    第三方可以通过 ContentResolver 来访问该 Provider。

### 2.为什么要用 ContentProvider？它和 sql 的实现上有什么差别？（★★★）

-   ContentProvider 屏蔽了数据存储的细节,内部实现对用户完全透明,用户只需要关心操作数据的 uri 就可以了，ContentProvider 可以实现不同 app 之间共享。
    Sql 也有增删改查的方法， 但是 sql 只能查询本应用下的数据库。而
    ContentProvider 还可以去增删改查本地文件. xml 文件的读取等。

-   ContentProvider主要是为了支持多个应用程序之间共享数据而设计的，而SQL主要是为了支持单个应用程序内的数据管理而设计的。此外，ContentProvider还提供了一些额外的功能，如**数据权限管理**和**数据URI**的支持，使应用程序可以更轻松地访问共享数据。

### 3.说说 ContentProvider、ContentResolver、ContentObserver之间的关系（★★★★）

ContentProvider、ContentResolver、ContentObserver是Android中用于实现跨应用程序数据共享的三个核心类，它们之间的关系如下：

1.  ContentProvider：用于在应用程序之间共享数据，可以将数据存储在数据库中或者以文件形式存储在磁盘上。ContentProvider会提供一些标准的CRUD操作（创建、读取、更新和删除）以及查询接口，其他应用程序通过**ContentResolver对象调用ContentProvider的接口**来访问数据。
2.  ContentResolver：用于在应用程序之间访问ContentProvider提供的数据。ContentResolver对象可以通过调用ContentProvider提供的接口实现数据的增删改查操作，并且可以**通过注册ContentObserver来监听数据的变化**。
3.  ContentObserver：用于监视ContentProvider中的数据变化，当数据发生变化时，ContentObserver会收到通知并触发回调函数。**其他应用程序可以通过ContentResolver注册ContentObserver来监听数据的变化**，从而实现实时更新数据的效果。

综上所述，ContentProvider是提供数据的地方，ContentResolver是访问数据的地方，而ContentObserver是用于监听数据变化的地方。它们三者配合使用可以实现应用程序之间数据的共享和实时更新。

### 4.如何使用 contentProvider 获取本地所有的音频文件（★★★）

Android 中，系统为多媒体类型的文件（比如图片、音频、视频等）建立了数据库(sqlite 数据库)，将文件的名称、大小等信息存储起来，从而完成多媒体数据的维护工作。

要使用ContentProvider获取本地所有的音频文件，可以执行以下步骤：

1.  获取ContentResolver对象，这个对象是用于和ContentProvider通信的接口。

```java
ContentResolver resolver = context.getContentResolver();
```

2.  构建查询的URI和投影（projection）数组，这个URI指向音频文件的存储位置，投影数组用于指定我们需要查询的列。

```java
Uri uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;
String[] projection = {
        MediaStore.Audio.Media._ID,
        MediaStore.Audio.Media.TITLE,
        MediaStore.Audio.Media.ARTIST,
        MediaStore.Audio.Media.DATA
};
```

3.  使用ContentResolver的query方法查询音频文件数据，该方法返回一个Cursor游标对象，其中包含了查询结果。

```java
Cursor cursor = resolver.query(uri, projection, null, null, null);
```

4.  遍历Cursor对象，从中获取音频文件的信息，例如文件名、路径、时长等。

```java
while(cursor.moveToNext()) {
    String title = cursor.getString(cursor.getColumnIndex(MediaStore.Audio.Media.TITLE));
    String artist = cursor.getString(cursor.getColumnIndex(MediaStore.Audio.Media.ARTIST));
    String path = cursor.getString(cursor.getColumnIndex(MediaStore.Audio.Media.DATA));
    long duration = cursor.getLong(cursor.getColumnIndex(MediaStore.Audio.Media.DURATION));
    // TODO: 处理获取到的音频文件信息
}
```

5.  最后，在使用完Cursor对象后，需要调用它的close方法关闭游标。

```java
cursor.close();
```

综上所述，通过以上步骤，可以使用ContentProvider获取本地所有的音频文件，并从中提取所需信息。需要注意的是，由于查询可能会返回大量数据，因此最好将查询放在异步线程中执行，以免阻塞UI线程。

同时因为是从本地读取数据，所以需要添加权限:
```xml 
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
```



## 五、 ListView

### 1.ListView 如何提高其效率？

-   复用ConvertView，使用历史的view
-   自定义静态类ViewHolder，减少findViewById 的次数
-   **异步加载数据**，**分页加载数据**
-   使用WeakRefrence 引用ImageView对象

### 2.当 ListView 数据集改变后，如何更新 ListView

使用该 ListView 的 adapter 的 `notifyDataSetChanged()`方法。该方法会使 ListView 重新绘制。

### 3.ListView 如何实现分页加载（★★★★★）

在 ListView 中添加滑动监听器。只关心静止状态：当滑动状态为 `SCROLL_STATE_IDLE`（即空闲状态）且滑动到底部时，触发分页加载的操作，关心最后一个可见的条目，如果最后一个可见条目就是数据适配器（集合）里的最后一个，此时可加载更多的数据。在每次加载的时候，计算出滚动的数量，当滚动的数量大于等于总数量的时候，可以提示用户无更多数据了。

### 4.ListView 可以显示多种类型的条目吗（★★）

是的，ListView 可以显示多种类型的条目。这通常称为多布局类型列表或多类型列表。

实现多类型列表的关键在于让 ListView 的 Adapter 可以处理多个不同类型的数据，并根据数据类型的不同，显示对应的条目布局。

一种实现方式是通过重写 Adapter 中的 getViewTypeCount 和 getItemViewType 方法。其中，getViewTypeCount 方法用于返回 ListView 中不同类型的视图的总数，而 getItemViewType 方法则用于返回指定位置上的数据项所使用的视图类型。在 getView 方法中，根据 getItemViewType 返回的视图类型，选择对应的布局来显示数据。

另一种实现方式是通过 RecyclerView 来实现多类型列表，其中 RecyclerView 中的 Adapter 支持多类型条目的显示，并且性能比 ListView 更好。RecyclerView 的实现方式类似于 ListView，需要重写 getItemViewType 和 onCreateViewHolder 方法，并在 onCreateViewHolder 方法中返回对应的 ViewHolder。

### 5.ListView 如何定位到指定位置

1.  ListView 定位到指定位置

（1）使用 `setSelection()` 方法

setSelection 方法可以让 ListView 滚动到指定位置，其中参数 position 表示要定位的位置。

例如，使用以下代码可以将 ListView 定位到第 10 个位置：

```java
listView.setSelection(9);
```

（2）使用 `smoothScrollToPosition()` 方法

smoothScrollToPosition 方法可以平滑地滚动到指定位置。

例如，使用以下代码可以让 ListView 平滑地滚动到第 10 个位置：

```java
listView.smoothScrollToPosition(9);
```

1.  RecyclerView 定位到指定位置

RecyclerView 中定位到指定位置的方法与 ListView 有所不同。通常使用以下方法来实现：

（1）使用 `scrollToPosition()` 方法

scrollToPosition 方法可以将 RecyclerView 定位到指定位置，其中参数 position 表示要定位的位置。

例如，使用以下代码可以将 RecyclerView 定位到第 10 个位置：

```java
recyclerView.scrollToPosition(9);
```

（2）使用 `smoothScrollToPosition()` 方法

smoothScrollToPosition 方法可以平滑地滚动到指定位置。

例如，使用以下代码可以让 RecyclerView 平滑地滚动到第 10 个位置：

```java
recyclerView.smoothScrollToPosition(9);
```

需要注意的是，RecyclerView 中的布局管理器可能会影响 scrollToPosition 和 smoothScrollToPosition 方法的表现。例如，LinearLayoutManager 支持垂直和水平滚动，而 GridLayoutManager 则支持网格布局。因此，在使用 RecyclerView 定位到指定位置时，需要注意当前使用的布局管理器是否支持相应的滚动方式。

### 6.如何在ScrollView 中如何嵌入 ListView（★★★★）

-   通常情况下我们不会在 ScrollView 中嵌套 ListView，但是如果必须嵌套的话也是可以的。
-   在 ScrollView 添加一个 ListView 会导致 listview 控件显示不全，通常只会显示一条，这是因为两个控件的滚动事件冲突导致。需要通过 listview 中的item 数量去计算 listview 的显示高度，从而使其完整展示。

### 7.ListView、RecyclerView 中如何优化图片（★★）

在 RecyclerView 中优化图片主要有以下几种方法：

1.  使用图片压缩

使用图片压缩可以减小图片的文件大小，从而减少内存的消耗。常用的图片压缩方法包括使用压缩库如 Luban、Tiny、Glide 等对图片进行压缩，或者使用 BitmapFactory.Options 对图片进行压缩处理。

2.  使用图片缓存

在加载图片时，使用图片缓存可以减少重复加载同一张图片的次数，从而提高图片加载速度，并减少内存的消耗。常用的图片缓存库包括 Glide、Picasso、Fresco 等。

3.  使用图片裁剪

使用图片裁剪可以将图片的大小裁剪为合适的尺寸，以适应显示的控件大小。可以使用 Glide、Picasso 等图片加载库中的裁剪方法，或者使用 BitmapFactory 对图片进行裁剪处理。

4.  延迟加载

可以使用 RecyclerView 中的 onScrollStateChanged 方法监听 RecyclerView 的滑动状态，并在滑动停止时才加载图片，从而减少内存的消耗。

5.  优化 ViewHolder

ViewHolder 是 RecyclerView 中用于缓存布局中各个视图的类。在 ViewHolder 中，可以使用 findViewById 方法对布局中的各个视图进行缓存，从而减少 findViewById 方法的调用次数，提高布局的加载速度。

综上所述，为了在 RecyclerView 中优化图片，需要使用图片压缩、图片缓存、图片裁剪、延迟加载等方法，并优化 ViewHolder 类的实现。

### 8.ListView 或 RecyclerView 中图片错位的问题是如何产生的（★★★）

ListView 或 RecyclerView 中图片错位的问题一般是由于以下原因造成的：

1.  布局复用问题

ListView 和 RecyclerView 的布局复用机制会导致视图的重复利用，即当一个视图滚动离开屏幕时，它会被回收，再次出现时会被重新利用，而不是重新创建。如果复用的视图中含有图片，并且在滚动时图片还未加载完成，就可能会导致图片错位的问题。

2.  图片加载问题

图片的加载可能会出现各种问题，如网络延迟、加载过程中被回收等，这些都可能导致图片显示错位的问题。另外，图片加载库的版本也可能影响图片错位的问题，因为不同版本的图片加载库实现方式可能不同。

3.  异步加载问题

如果使用异步加载图片，那么当图片加载完成时，可能已经滚动到了另一个位置，此时加载的图片可能会显示在错误的位置，导致图片错位。

4.  布局中图片的位置计算问题

如果布局中包含多个 ImageView，并且它们的位置是根据其他视图计算得出的，那么在滚动时，可能会导致位置计算出现错误，从而导致图片错位的问题。



为了解决图片错位的问题，可以采取以下措施：

1.  在布局中使用占位符

在布局中使用占位符，例如使用空白的 View 或者 ProgressBar 来占据图片的位置，等到图片加载完成后再将占位符替换成真正的图片。

2.  使用图片加载库

使用图片加载库可以有效地解决图片加载问题，例如 Glide、Picasso 等都提供了缓存机制和异步加载机制，可以有效地避免图片错位的问题。

3.  同步更新数据源

及时更新数据源可以保证 ListView 或 RecyclerView 中的数据与实际情况相符，避免出现图片错位等问题。

4.  使用布局中视图的唯一标识符

在使用 RecyclerView 时，可以使用视图的唯一标识符来避免视图错位的问题。通过 getItemId 方法返回视图的唯一标识符，可以确保 RecyclerView 中的视图与数据源相对应。

10. ### 如何刷新 ListView或RecyclerView 中单个 item 的数据， 不刷新整个ListView或RecyclerView 的数据？

修改单个 Item 的数据,然后调用适配器的 `notifyDataSetChanged()` 方法



### 六、Intent

1.   ### Intent 传递数据时，可以传递哪些类型数据？

 	1. 基本数据类型
 	2. 字符串
 	3. 数组
 	4. 实现了 Serializable 或 Parcelable 接口的对象
 	5. Bundle 对象

### 2.Serializable 和Parcelable 的区别（★★★）

1.  序列化方式不同：

Serializable 使用 Java 自带的序列化机制，在序列化和反序列化时需要进行大量的 I/O 操作，效率较低。而 Parcelable 使用 Android 提供的 Parcelable 机制，在序列化和反序列化时只需要进行内存操作，效率更高。

2.  传递数据的大小：

Serializable 在序列化过程中会产生大量的中间对象，这些对象会占用较大的内存空间，因此在传递较大的数据时，可能会导致内存不足的问题。而 Parcelable 机制可以通过重用对象池来避免这个问题。

3.  实现方式不同：

Serializable 只需要实现一个接口即可，而 Parcelable 则需要手动实现 writeToParcel() 和 createFromParcel() 两个方法。

4.  可读性不同：

Serializable 生成的序列化数据是基于 Java 类型的反射机制，可读性较强，而 Parcelable 生成的序列化数据比较难以阅读。

### 3.请描述一下 Intent 和 IntentFilter（★★★）

Intent 和 IntentFilter 是 Android 中非常重要的两个类，它们分别用于表示一个操作或者一组操作，以及用于过滤对应操作的条件。

具体来说，Intent 代表了一个应用程序执行的某个动作，可以包含一些额外的数据，比如要启动的 Activity、要执行的 Service、要广播的消息等等。通过 Intent，我们可以在应用程序之间进行通信，或者在应用程序内部进行组件之间的跳转。

而 IntentFilter 则是一组条件，用于描述哪些操作可以响应当前的 Intent。IntentFilter 包含了一些 **Action**、**Category** 和 **Data** 等信息，其中 **Action 表示当前 Intent 的动作**，Category 表示当前 Intent 的类型，**Data 则表示当前 Intent 操作所要操作的数据**。通过对 IntentFilter 进行匹配，系统可以找到合适的组件来响应当前的 Intent。

通常情况下，我们在启动 Activity、Service、广播等组件时，都需要通过 Intent 来指定具体的操作，并通过 IntentFilter 来确保当前的操作能够被正确地处理。例如，我们可以通过指定 Action 和 Category 来启动一个特定的 Activity，或者通过指定 Action 来发送一个广播消息，等等。

### 4.intent 的意义

实现组件之间通信和跳转的核心机制



## 七、Fragment

### 1.Fragment 跟Activity 之间是如何传值的

1.   Bundle
     在 Activity 中创建一个 Bundle 对象，然后调用 Fragment setArguments() 方法来传递数据。在 Fragment 中，我们可以通过 getArguments() 方法获取到这个 Bundle 对象，并从中获取我们需要的数据。
     在 Activity 中：

     ```java
     Bundle bundle = new Bundle(); 
     bundle.putString("key", "value"); 
     MyFragment fragment = new MyFragment(); fragment.setArguments(bundle);
     ```

     在 Fragment 中：
     ```java
     Bundle bundle = getArguments();
     if (bundle != null) {
         String value = bundle.getString("key");
     }
     ```

     

2.   接口回调
     通过在 Fragment 中定义一个接口，在 Activity 中实现该接口，并将 Activity 的实例作为参数传递给 Fragment，从而让 Fragment 可以调用 Activity 中的方法来传递数据。这种方式适用于需要在 Fragment 中触发 Activity 中的一些操作或者传递复杂数据的情况。

3.   直接调用 Activity 方法：在 Fragment 中通过 `getActivity()`方法获取到 Activity 的实例，然后直接调用 Activity 的方法来传递数据。在 Activity 中可以通过 `fragmentManager.findFragmentById(id)` 获取到 Fragment 实例，获取到 Fragment 之后就可以调用 Fragment 的方法。。这种方式比较简单，但需要注意避免内存泄漏。

4.   ViewModel：通过在 Fragment 和 Activity 中共享 ViewModel 对象，从而实现数据共享。这种方式适用于需要在 Fragment 和 Activity 中共享数据的情况。

### 2.描述一下 Fragment 的生命周期

1.   onAttach()：当 Fragment 被添加到 Activity 中时，该方法被调用，表示 Fragment 已经与 Activity 关联。
2.   onCreate()：该方法被调用时，表示 Fragment 正在创建。在该方法中通常进行一些初始化操作，例如设置布局等。
3.   onCreateView()：该方法被调用时，表示 Fragment 的布局已经创建完成，但还未添加到视图中。在该方法中通常创建和返回 Fragment 的视图。
4.   onActivityCreated()：该方法被调用时，表示 Fragment 所依赖的 Activity 已经完成 onCreate() 方法的执行。在该方法中通常进行一些需要访问 Activity 的操作。
5.   onStart()：该方法被调用时，表示 Fragment 正在启动。在该方法中通常进行一些 UI 显示相关的操作。
6.   onResume()：该方法被调用时，表示 Fragment 已经显示在屏幕上，并且用户正在与之交互。在该方法中通常进行一些用户交互相关的操作。
7.   onPause()：该方法被调用时，表示 Fragment 正在暂停。在该方法中通常进行一些与用户交互相关的操作的暂停。
8.   onStop()：该方法被调用时，表示 Fragment 已经停止。在该方法中通常进行一些 UI 显示相关的操作的停止。
9.   onDestroyView()：该方法被调用时，表示 Fragment 的视图正在被销毁。在该方法中通常进行一些与视图相关的清理操作。
10.   onDestroy()：该方法被调用时，表示 Fragment 正在被销毁。在该方法中通常进行一些与资源相关的清理操作。
11.   onDetach()：该方法被调用时，表示 Fragment 已经与 Activity 分离。在该方法中通常进行一些与 Activity 解除关联的操作。

<img src="https://cdn.jsdelivr.net/gh/ChengYang1998/blogImage@main/PicGo/image-20230325135510255.png" alt="image-20230325135510255" style="zoom: 50%;" />



### 3.FragmentManager 的 replace 和 add 两种方法切换Fragment 时有什么不同

1.   replace 方法：使用该方法会将当前的 Fragment 替换为指定的 Fragment，也就是说，当前的 Fragment 不再保留在后台栈中，完全被新的 Fragment 替代。使用 replace 方法进行 Fragment 切换时，原来的 Fragment 的生命周期方法 onPause()、onStop()、onDestroyView()、onDestroy()、onDetach() 将被依次调用。同时，新的 Fragment 的生命周期方法 onAttach()、onCreate()、onCreateView()、onActivityCreated()、onStart()、onResume() 将依次被调用。

2.   add 方法：使用该方法会将指定的 Fragment 添加到当前的 Fragment 上方，即将新的 Fragment 添加到当前的 Fragment 后面。使用 add 方法进行 Fragment 切换时，当前的 Fragment 不会被销毁，而是保留在后台栈中，可以通过返回键重新回到该 Fragment。同时，新的 Fragment 的生命周期方法 onAttach()、onCreate()、onCreateView()、onActivityCreated()、onStart()、onResume() 将依次被调用，原来的 Fragment 的生命周期方法不会被调用。

### 4.Fragment 如何实现类似Activity 栈的压栈和出栈效果的？

-   在 FragmentManager 中，维护了一个 Fragment 栈来保存所有的 Fragment，一个指针来指示当前栈顶的 Fragment。

-   FragmentFragmentManager 内部实现了一个 BackStackRecord 类，它可以看作是一个包含多个操作的栈，其中操作包括添加、替换、移除 Fragment 等等。每当一个新的操作被执行时，FragmentManager 会将其添加到 BackStackRecord 中，并将该 BackStackRecord 放入一个栈中，这个栈可以看作是 Fragment 栈，保存了所有的 BackStackRecord。当用户按下 Back 键时，FragmentManager 会从 Fragment 栈中取出最后一个 BackStackRecord，然后反向执行其中的操作，实现了 Fragment 的退栈操作。

-   因此，可以说 FragmentManager 的内部实现既不是简单的数组实现，也不是双向链表结构，而是一种基于栈的实现方式。

### 5.Fragment 在项目中的使用

1.   模块化：独立设计、测试和调试
2.   可重用性：减少了代码的重复。
3.   Fragment 可以在运行时动态添加、移除、替换和组合。
4.   屏幕适配性
5.   状态保存：Fragment 可以帮助开发人员保存 Activity 中的状态信息，这使得当 Activity 被销毁后可以快速地恢复状态信息。

### 6.如何切换 fragement,不重新实例化

可以使用 FragmentTransaction 类的 replace() 方法来切换 Fragment，而不需要重新实例化：

1.   获取 FragmentManager 对象，通常可以通过调用`getActivity().getSupportFragmentManager()` 或 `getChildFragmentManager()` 方法来获取。
2.   创建一个 FragmentTransaction 对象，可以通过调用 FragmentManager 的 `beginTransaction()` 方法来创建。
3.   使用 FragmentTransaction 的 `replace()` 方法来替换当前的 Fragment，该方法接受三个参数：**容器视图 ID**、**要添加的 Fragment** 和**标记（可选）**。
4.   调用 FragmentTransaction 的 `commit()` 方法来提交事务。

例如，假设我们有两个 Fragment，分别为 FragmentA 和 FragmentB，如果要从 FragmentA 切换到 FragmentB，可以使用以下代码：
```java
FragmentB fragmentB = new FragmentB();
FragmentManager fragmentManager = getActivity().getSupportFragmentManager();
FragmentTransaction transaction = fragmentManager.beginTransaction();
transaction.replace(R.id.container, fragmentB, "FragmentBTag");
transaction.addToBackStack(null);
transaction.commit();
```

其中，R.id.container 是要用来显示 Fragment 的容器视图 ID，`"FragmentBTag"` 是用来标记 Fragment 的字符串，`addToBackStack(null)` 方法将当前的 Fragment 添加到返回堆栈中，以便在用户按下返回按钮时可以返回到 FragmentA。注意，在切换 Fragment 时，需要使用要切换到的 Fragment 的实例来替换当前的 Fragment。



# 第二章：Android 高级

## 一、Android 性能优化

### 1、如何对 Android 应用进行性能分析（★★★★）

TraceView、Android Profiler、Systrace、Memory Profiler、Network Profiler等常规工具，还有以下几个新的工具：Jetpack Benchmark、Android Vitals、LeakCanary

### 2、什么情况下会导致内存泄露（★★）

1.  静态引用：static 是 Java 中的一个关键字，当用它来修饰成员变量时，那么该变量就属于该类，而不是该类的实例。所以用 static 修饰的变量，它的生命周期是很长的，如果用它来引用一些资源耗费过多的实例（Context 的情况最多），这时就要谨慎对待了。
    如果您在代码中使用静态引用，它将会持有一个对象的引用，这个对象可能已经不再需要，但是由于静态引用，它将无法被垃圾回收器释放，导致内存泄漏。

    ```java
    public class ClassName {
        private static Context mContext;
        //省略
    }
    ```

    以上的代码是很危险的，如果将 Activity 赋值到 mContext 的话。那么即使该 Activity 已经 onDestroy，但是由于仍有对象保存它的引用，因此该 Activity 依然不会被释放。

2.  长时间的后台任务：如果您的应用程序在后台运行，并且持续进行某个操作，但是没有及时释放资源，这将会导致内存泄漏。例如，如果您使用了 Handler 或者 Timer，但是没有及时取消它们，它们将会持有 Activity 的引用，这将会阻止垃圾回收器回收 Activity。

3.  匿名内部类：如果您在 Activity 或者 Fragment 中使用匿名内部类，并且这个内部类持有 Activity 或者 Fragment 的引用，这将会导致内存泄漏。因为匿名内部类在编译时会生成一个新的类，而这个类会持有外部类的引用，如果您没有及时取消对匿名内部类的引用，这将会导致内存泄漏。

4.  Bitmap 对象：如果您在应用程序中使用 Bitmap 对象，并且没有及时释放它们，这将会导致内存泄漏。因为 Bitmap 对象通常非常大，如果没有及时回收，它们将会占用大量内存。

5.  生命周期不当：如果您的应用程序中的某个对象生命周期不当，例如它在 Activity 或者 Fragment 销毁后仍然存在，这将会导致内存泄漏。

6.  线程导致内存溢出

    当创建线程时，线程会持有一个对其所属的线程组的引用，而线程组又会持有一个对所有线程的引用。如果您在 Activity 或者 Fragment 中创建了一个线程，但是没有及时取消对线程的引用，那么该线程将会一直存在，直到应用程序退出或者被强制终止。

    此外，当在应用程序中使用线程池时，线程池中的线程也可能导致内存泄漏。如果您使用的线程池是静态的，并且您没有及时清除已完成的任务，那么这些线程将会一直存在，直到应用程序退出或者被强制终止。

    ```java
    public class MyActivity extends Activity {
    
        @Override
        public void onCreate(Bundle savedInstanceState) { 
            super.onCreate(savedInstanceState); 
            setContentView(R.layout.main);
            new MyThread().start();
        }
        
        private class MyThread extends Thread{
            @Override
            public void run() {
                super.run();
                //do somthing while(true)
            }
        }
    }
    ```

    假设 MyThread 的 run 函数是一个很费时的操作，当我们开启该线程后，将设备的横屏变为了竖屏，一般情况下当屏幕转换时会重新创建 Activity，按照我们的想法，老的 Activity 应该会被销毁才对，然而事实上并非如此。

    由于我们的线程是 Activity 的内部类，所以 MyThread 中保存了 Activity 的一个引用，当 MyThread 的 run 函数没有结束时，MyThread 是不会被销毁的，因此它所引用的老的 Activity 也不会被销毁，因此就出现了内存泄露的问题。

    为了避免内存泄漏问题，可以使用**弱引用**来保存 Context 对象的引用，这样当 Context 不再被使用时，垃圾收集器可以自动回收它。

    以下是一个在线程内部使用弱引用保存 Context 引用的示例：

    ```java
    public class MyRunnable implements Runnable {
        private WeakReference<Context> mContextRef;
    
        public MyRunnable(Context context) {
            mContextRef = new WeakReference<>(context);
        }
    
        @Override
        public void run() {
            Context context = mContextRef.get();
            //检查其是否已经被回收
            if (context != null) {
                // 在线程中使用 Context 对象
                Toast.makeText(context, "Hello World!", Toast.LENGTH_SHORT).show();
            }
        }
    }
    ```

    在上面的示例中，定义了一个名为 `MyRunnable` 的线程类，该类的构造函数接受一个 Context 对象，并使用弱引用来保存该对象的引用。在 `run()` 方法中，首先获取弱引用的 Context 对象，如果该对象不为空，则可以在线程中使用它。如果 Context 对象已经被回收，则不会进行任何操作。

### 3、如何避免 OOM 异常（★★★★）

1.  优化图片资源的加载和显示。图片资源占用内存较大，特别是加载大图片时容易导致 OOM 异常。可以通过使用合适的图片压缩技术、延迟加载、缓存等方式来优化图片资源的加载和显示。
2.  避免内存泄漏。在 Android 中，内存泄漏是引发 OOM 异常的主要原因之一。可以通过避免静态变量持有 Activity 的引用、正确地使用 Context 等方式来避免内存泄漏。
3.  释放不再使用的资源。及时释放不再使用的资源，包括 Bitmap、File、数据库连接、流等，可以有效地避免 OOM 异常。
4.  使用更高效的数据结构。有些数据结构，如 ArrayList、HashMap，在数据量较大时容易引起 OOM 异常。可以使用更高效的数据结构，如 SparseArray、ArrayMap、LruCache 等，来优化内存使用。
5.  控制并发线程数量。过多的并发线程也容易引发 OOM 异常。可以通过线程池来控制并发线程的数量，以减轻内存压力。
6.  使用分页加载技术。对于大数据量的列表，可以使用分页加载技术，避免一次性加载所有数据导致 OOM 异常。

总的来说，避免 OOM 异常需要从多个方面进行优化，包括资源的加载和释放、数据结构的选择、并发线程数量的控制等，需要综合考虑应用程序的实际情况进行优化。

### 4、Android 中如何捕获未捕获的异常（★★★）

在应用程序的主线程中设置默认的未捕获异常处理器。这可以通过 `Thread.setDefaultUncaughtExceptionHandler()` 方法来实现。可以在自定义的异常处理器中对异常进行记录、上传、打印等操作。例如：

1.   自定义一个 Application，比如叫 MyApplication 继承 Application 实现 UncaughtExceptionHandler。
2.   覆写UncaughtExceptionHandler 的onCreate 和uncaughtException 方法。

```java

```









