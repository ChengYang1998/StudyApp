# Android八股文 - Chip - 2023



## 一、Activity



### 1.什么是activity？

- 四大组件之一

- Context 子类
- 实现了 window.callback 和 keyevent.callback ，可以处理窗体与用户交互的事件
- 开发常用：FragmentActivitiy、TabAcitivty、ListActivity

### 2.请描述Activity生命周期

- Activity从创建到销毁有多种状态，从一种状态到另一种状态时会激发相应的回调方法。

包括：onCreate创建 onStart可见 onResume焦点 onPause不可编辑 onStop不可见 onDestory销毁

这些方法两两对应。

### 3.Activity生命周期  

### 4.保存 Activity 的状态或者（ Activiy 重启怎么保存数据？）

- Activity 的状态通常情况下系统会自动保存的，只有当我们需要保存额外的数据时才需要使用到这样的功能。

- 通常：调用`onPause()`和`onStop()`方法后的activity 实例仍然存在于内存中，activity 的所有信息和状态数据不会消失，当 activity 重新回到前台之后，所有的改变都会得到保留。

- 内存不足时：调用`onPause()`和`onStop()`方法后的activity 可能会被系统摧毁，activity 重新回到前台, 之前所作的改变就会消失。
- 解决方法：可以覆写 `onSaveInstanceState()`方法，他接受一个 Bundle 类型的参数, 开发者可以将状态数据存储到这个 Bundle 对象中，在 onPause()或 onStop()方法之前调用 `onSaveInstanceState()`。重新启动这个 activity 而调用它的`onCreate()`方法时, 上述的Bundle 对象会作为实参传递给 `onCreate()`方法，开发者可以从 Bundle 对象中取出保存的数据, 然后利用这些数据将 activity 恢复到被摧毁之前的状态。

- 注意：用户按下 BACK 键退出 activity 时, 用户显然想要关闭这个 activity，`onSaveInstanceState()`方法不会被调用。

```java
@Override
protected void onSaveInstanceState(Bundle outState) {
// TODO Auto-generated method stub
super.onSaveInstanceState(outState);
}
```

### 5、 两个 Activity 之间跳转时必然会执行的是哪几个方法？

- 当Activity **A**跳转到**B**时，**A**会调用onPause()方法，然后**B**调用onCreate(),onStart(),onResume()方法。
- 如果**B**覆盖了窗体，**A**会调用onStop()方法；如果**B**是透明的或者是个对话框，**A**不会调用onStop()方法。

### 6、 横竖屏切换时Activity 的生命周期（★★★★）

activity 在配置更改时（如屏幕方向、键盘可用性、语言、屏幕大小等）和**清单文件里的配置**有关系。

- 不设置 Activity 的 android:configChanges 时，切屏会重新调用各个生命周期默认首先销毁当前 activity,然后重新加载。
- 当 android:configChanges 属性设置了某些选项时，每次发生对应的更改时，Android 系统不再销毁并重新创建该 activity，而是会调用该 activity 的 `onConfigurationChanged()` 方法。因此，在该方法中，开发者需要自行处理相关的逻辑以适应新的配置状态。

### 7、 如何将一个 Activity 设置成窗口的样式

将 Activity 配置如下属性即可。

android:theme="@android:style/Theme.Dialog"

### 8、 如何退出 Activity ？ 如何安全退出已调用多个Activity 的 Application？（★★★★）


1. 用户：退出一个 Activity 只需按返回键

   开发者：调用`finish()`

2. 递归退出
   在打开新的 Activity 时使用 startActivityForResult，然后自己加标志，在onActivityResult 中处理，递归关闭。

   

3. 记录打开的 Activity：

   维护一个Activity List记录打开的每一个Activity，在需要退出时，循环finish每一个 Activity 即可。

```java
List<Activity> lists ;// 在 application 全局的变量里面
lists = new ArrayList<Activity>();
lists.add(this);
for(Activity activity: lists){
	activity.finish();
}
lists.remove(this);
```

4. 发送特定广播：

   在需要结束应用时，发送一个特定的广播，每个 Activity 收到广播后，关闭即可。

   ```java
   //给某个 activity 注册接受接受广播的意图
   registerReceiver(receiver, filter)
   //如果接受到 关闭 activity 的广播 就调用 finish() 方法 把当前的 activity finish()掉
   ```

5. 通过 intent 的 flag 来实现

```java
intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
```

- 激活一个新的 activity，此时会把该任务栈中这个 Activity 上面的所有Activity 清除。

- 相当于给 Activity 配置的启动模式为 SingleTop。

### 9、 Activity 的 四 种 启 动 模 式 ， singletop 和singletask 区别是什么？一般书签的使用模式是 singletop ，那为什么不使用  singletask ?

- singleTop 跟 standard 模式比较类似。**唯一的区别**就是：

  当跳转的对象是位于栈顶的 activity（应该可以理解为用户眼前所 看到的 activity）时，程序**将不会生成一个新的activity 实例**，而是直接跳到现存于栈顶的那个 activity 实例。拿上面的例子来说，当 Act1 为 singleTop 模式时，执行跳转后栈里面依旧只有一个实例，如果现在按返回键程序将直接退出。

- singleTask 模式和 singleInstance 模式都是只创建一个实例的。在这种模式下，若栈里面已经有这个实例，无论跳转的对象是不是位于栈顶的 activity，程序都不会生成一个新的实例。指定singleInstance模式的Activity会启用一个新的返回栈来管理这个Activity。

- 在一般情况下，使用 singleTop 模式是比较合适的，因为使用这种模式可以避免很多意外情况，相比之下，使用 singleTask 模式需要考虑更多的因素，因此并不是所有的场景都适用。比如：使用 singleTask 模式时，当在一个 task 中已经存在目标 Activity 的实例时，操作返回时栈顶会将中间的所有 Activity 移除，从而可能导致一系列操作后得到的返回结果不一致，需要进行特殊处理。

### 10、Android 中的 Context, Activity，Appliction 有什么区别？（★★）

- 相同点：Activity和Application都是Context的子类。

- Context指上下文的意思，实际应用中起**管理上下文环境中各个参数各变量的作用**，方便我们可以简单的访问到各种资源。

- 不同点：维护的生命周期不同：

  Context维护的是当前Activity的生命周期，Application维护的是整个项目的生命周期。

- 使用 context 的时候，要防止内存泄露，需要注意一下几个方面：

  1. 不要让生命周期长的对象引用 activity context，即保证引用 activity 的对象要与 activity 本身生命周期是一样的。
  2. 对于生命周期长的对象，可以使用 application，context。
  3. 避免非静态的内部类，**尽量使用静态类**，避免生命周期问题，注意内部类对外部对象引用导致的生命周期变化。

### 11、两个Activity 之间传递数据，除了 intent，广播接收者，content provider 还有那些方法？

1. static静态数据，public static 成员变量
2. 利用外部存储的传输， 例如：File 文件存储、SharedPreferences 轻量级的存储类、Sqlite 数据库

### 12、Context 是 什 么 ？ ， 一 个 应 用 有 多 少 个 Context(2020.5.15）（★★）

1. 它描述的是一个应用程序环境的信息，即上下文，起**管理上下文环境中各个参数各变量的作用**，方便我们可以简单的访问到各种资源。
2. 该类是一个抽象(abstract class)类，Android 提供了该抽象类的具体实现类（ContextIml）。
3. 通过它我们可以获取应用程序的资源和类，也包括一些应用级别操作， 例如：启动一个 Activity，发送广播，接受 Intent，信息等。
4. **一个应用 Context 数量**=**Activity 个数** + **service 个数** + 1 个

### 13.activity 之间还有 activity 和 service 之间如何传值，可以传图片吗？



- Activity 之间传值：

  使用Intent：通过 Intent 对象的各种 putExtra 方法来进行传递。在第二个 Activity 对象中，可以通过 `getIntent()` 方法来得到跳转到这个 Activity 的 Intent 对象，然后通过 Intent 对象的各种 getXXExtra 方法来得到我们的传过来的值。

- Activity 和 Service 之间传值：

  1. 通过 `startService（intent）`使用Intent传值。

     此时需要在清单文件中注册这个Service

  ```xml
  <service Android:enabled="true" android:name=".Service">
  </service>
  ```

  2. Service 可以从 `public int onStartCommand(Intent intent, int flags, int startId)`中取出从 activity 中传过来的值。`intent.getExtra()`获得 bundle 对象， 可从中取值。

  3. Activity 也可以用 bindService(intent, conn,BIND_AUTO_CREATE);传值，把要传的值绑定在 intent 里，在 service 的 `public IBinder onBind(Intent intent)` 方法里取得 intent 。
  4. 可以在 reseiver 里面注册一个广播，在 activity 里`sendbroadcast(intent)`传值。

- 可以传递图片：用 Intent 把**图片的地址**或者把**图片对象**用 Intent 传过去，用**bitmap** 对象。

  

## 二、Service

### 1.Service是否在main thread中执行，Service里面是否能执行耗时操作？（★★）

- 若未显式声明Service所运行的进程，Service和Activity是运行在dangqianapp所在进程的main thread（UI主线程）里面。

    不可执行耗时操作，如：网络请求、拷贝数据库、大文件

- 可以在清单文件中配置Service执行所在的进程，让Service在另外的进程中执行

  ```xml
  <service
  	android:name="com.baidu.location.f" 
  	android:enabled="true" 
  	android:process=":remote" >
  </service>
  ```

### 2.Activity怎么和Service绑定，怎么在Activity中启动自己对应的Service？

- Activity通过`bindService(Intent service,ServiceConnection conn,int flags)`同Service进行绑定，当绑定成功的时候Service会将代理对象通过回调的形式传给conn，就可以拿到Service提供的服务代理对象。
- 可以通过startService和bindService启动Service。想获取Service的服务对象，需要`bindService()`方法，如音乐播放器或第三方支付。
- 如果仅仅为了开启一个后台任务可以使用startService()方法。

### 3.描述Service的生命周期（★★★）

Service有非绑定模式、绑定模式、这两种的混合方式。不同使用方法生命周期不同。

- 非绑定模式：第一次调用startService的时候，执行方法依次为：`onCreate()`、`onStartCommand()`，当Service关闭的时候调用`onDestory()`方法。
- 绑定模式：第一次调用bindService()的时候，执行方法依次为：`onCreate()`、`onBind()`，解除绑定的时候会执行 `onUnbind()`、`onDestory()`。

> 上面的两种生命周期是在相对单纯的模式下的情形。我们在开发的过程中还必须注意 Service 实例只会有一个，也就是说如果当前要启动的 Service 已经存在了那么就不会再次创建该 Service 当然也不会调用 onCreate（）方法。
>



> 一个 Service 可以被多个客户进行绑定，只有所有的绑定对象都执行了
> onBind（）方法后该 Service 才会销毁，不过如果有一个客户执行了 onStart() 方法，那么这个时候如果所有的 bind 客户都执行了 unBind()该 Service 也不会销毁。



<img src="https://cdn.jsdelivr.net/gh/ChengYang1998/blogImage@main/PicGo/image-20230322103750747.png" alt="image-20230322103750747" style="zoom:67%;" />

### 4.什么是IntentService？有何优点？（★★★）

> 我们通常只会使用 Service，可能 IntentService 对大部分同学来说都是第一次听说。那么看了下面的介绍相信你就不再陌生了。如果你还是不了解那么在面试的时候你就坦诚说没用过或者不了解等。并不是所有的问题都需要回答上来的。

1. IntentService简介

   - IntentService是Service的子类，比普通Service增加了额外的功能

   - Service 本身存在两个问题：
     1. Service 不会专门启动一条单独的进程，Service 与它所在应用位于同一个进程中
     2. Service 也不是专门一条新线程，因此不应该在 Service 中直接处理耗时的任务


2. IntentService特征

   - 会创建独立的worker线程来处理**所有的Intent请求**
   
   - 会创建独立的worker线程来处理`onHandleIntent()`方法实现的代码，无需处理多线程问题
   
   - 所有请求处理完成后，IntentService 会自动停止，无需调用 stopSelf()方法停止 Service
   
   - 为 Service 的 `onBind()`提供默认实现，返回 null
   
   - 为 Service 的 `onStartCommand()` 提供默认实现，将请求 Intent 添加到队列中
   
3. 使用 IntentService

   IntentService使用例。

   - MainActivity.java:

   ```java
   public void click(View view) {
   	Intent intent = new Intent(this, MyIntentService.class); 					intent.putExtra("start", "MyIntentService"); 
       startService(intent);
   }
   ```
   -   MyIntentService.java

   ```java
   public class MyIntentService extends IntentService {
   	private String ex = "";
       private Handler mHandler = new Handler() {
           public void handleMessage(android.os.Message msg) {
               Toast.makeText(MyIntentService.this, "-e " + ex,Toast.LENGTH_LONG).show();
           }
       };
       
       public MyIntentService() { 
           super("MyIntentService");
       }
   
    
       @Override
       public int onStartCommand(Intent intent, int flags, int startId) { 
           ex = intent.getStringExtra("start");
           return super.onStartCommand(intent, flags, startId);
       }
   
      /**
   		* 模拟执行耗时任务
   		* 该方法是在子线程中执行的，因此需要用到 handler 跟主线程进行通信
   		*/
       @Override
       protected void onHandleIntent(Intent intent) {
        
           try {
               Thread.sleep(1000);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
           mHandler.sendEmptyMessage(0);
           try {
               Thread.sleep(1000);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
       }
   }
   ```


### 5.Activity、Intent、Service关系

- Activity、Service是四大组件之一，都是 Context 类的子类ContextWrapper 的子类。
- Activity 负责用户界面的显示和交互，Service 负责后台任务的处理。
- Activity 和 Service 之间可以通过 Intent 传递数据。

### 6.Service 和Activity 在同一个线程吗（★）

未显式声明的情况下都在UI线程。

### 7.Service 里面可以弹吐司么（★）

可以的。弹吐司有个条件就是得有一个 Context 上下文，而 Service 本身就是 Context 的子类，因此在 Service 里面弹吐司是完全可以的。比如我们在Service 中完成下载任务后可以弹一个吐司通知用户。

### 8.什么是 Service 以及描述下它的生命周期。Service 有哪些启动方法，有什么区别，怎样停用Service？（★★★）

在Service 的生命周期中，被回调的方法比 Activity 少一些，只有 onCreate, onStart, onDestroy,
onBind 和 onUnbind。
通常有两种方式启动一个 Service,他们对 Service 生命周期的影响是不一样的。

1. 通过 startService
    Service 会经历 onCreate 到 onStart，然后处于运行状态，stopService 的时候调用 onDestroy 方法。
    如果是调用者自己直接退出而没有调用 stopService 的话，Service 会一直在后台运行。
2. 通过 bindService
    Service会运行onCreate，然后是调用onBind，这个时候调用者和Service绑定在一起。调用者退出了，Srevice 就会调用 onUnbind->onDestroyed 方法。

所谓绑定在一起就共存亡了。调用者也可以通过调用 unbindService 方法来停止服务，这时候 Srevice 就会调用 onUnbind -> onDestroyed 方法。

如果这几个方法交织在一起的话，会出现什么情况？

- 一个原则是 Service 的 **onCreate 的方法只会被调用一次**，就是你无论多少次的startService 又 bindService，Service 只被创建一次。
- 如果先是 bindService  了，那么 start 的时候就直接运行 Service 的 onStart 方法， 如果先是 startService ，那么 bind 的时候就直接运行 onBind 方法。
- 如果 service 运行期间调用了 bindService，这时候再调用 stopService 的话，service 是不会调用 onDestroy 方法的，service 就 stop 不掉了，只能调用UnbindService, service 就会被销毁
- 如果一个 service 通过 startService 被 start 之后，多次调用 startService的话，service 会多次调用 onStart 方法。多次调用 stopService 的话，service 只会调用一次 onDestroyed 方法。
- 如果一个 service 通过 bindService 被 start 之后，多次调用 bindService 的话，service 只会调用一次 onBind 方法。**多次调用 unbindService 的话会抛出异常**。

### 9.在Service的生命周期方法onstartCommand()可不可以执行网络操作？如何在Service中执行网络操作？

可以在 `onStartCommand()` 方法中执行网络操作，但需要注意一些细节。

在执行网络操作时，需要在一个独立的线程中进行，以避免在主线程中阻塞。因此，在 `onStartCommand()` 中启动一个新的线程，并在该线程中执行网络操作是一个好的选择。

以下是一个示例，说明如何在 Service 中执行网络操作：

```java
public class MyService extends Service {
    private Thread mThread;

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        mThread = new Thread(() -> {
            // 在这里执行网络操作
            // ...

            // 在完成操作后，调用stopSelf()以停止服务
            stopSelf();
        });
        mThread.start();
        return START_NOT_STICKY;
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        if (mThread != null) {
            mThread.interrupt();
        }
    }

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }
}

```

在上面的示例中，我们在 `onStartCommand()` 方法中创建一个新的线程，并在其中执行网络操作。在完成操作后，我们调用 `stopSelf()` 方法以停止服务。在 `onDestroy()` 方法中，我们中断线程，以确保线程在服务销毁时被正确地终止。



## 三、Broadcast Receiver

### 1.请描述一下 BroadcastReceiver（★★）

- 定义：BroadcastReceiver是Android应用程序中的一个组件，用于接收系统或app发送的广播消息，并根据需要执行相应的操作。广播消息是一种用于应用程序间通信和事件传递的机制，可以在应用程序内部、跨应用程序和系统级别上发送和接收广播消息。
- BroadcastReceiver实现了一个特定的Java接口，并在应用程序的清单文件中注册，并且声明它所匹配的广播消息类型。当一个匹配的广播消息被发送时，系统将自动调用BroadcastReceiver的`onReceive()`方法，其中包含接收到的广播消息的信息。开发人员可以根据需要在`onReceive()`方法中编写自己的代码，例如启动服务、更新UI等等。
- 广播分两种：**有序广播**和**无序广播**。
- 内部通信实现机制：通过 Android 系统的 **Binder** 机制实现通信。
- 无序广播：完全异步，逻辑上可以被任何广播接收者接收到。优点是效率较高。缺点是一个接收者不能将处理结果传递给下一个接收者，并无法终止广播 intent 的传播。
- 有序广播：按照被接收者的优先级顺序，在被接收者中依次传播。比如有三个广播接收者 A，B，C，优先级是 A > B > C。那这个消息先传给 A，再传给 B，最后传给 C。每个接收者有权终止广播，比如 B 终止广播，C 就无法接收到。此外 A 接收到广播后可以对结果对象进行操作，当广播传给 B 时，B 可以从结果对象中取得 A 存入的数据。
- 通过 `Context.sendOrderedBroadcast(intent, receiverPermission,resultReceiver, scheduler, initialCode, initialData, initialExtras)`可以指定 resultReceiver 广播接收者，这个接收者认为是最终接收者。通常情况下如果比他优先级更高的接收者如果没有终止广播，那么他的`onReceive()`会被**执行两次**。第一次是正常的**按照优先级顺序执行**，第二次是**作为最终接收者接收**（如果比他优先级高的接收者终止了广播，那么他依然能接收到广播）。
- 例如：在我们的项目中经常使用广播接收者接收系统通知，比如开机启动、sd 挂载、低电量、外播电话、锁屏，如果我们做的是播放器，那么监听到用户锁屏后我们应该将我们的播放暂停。

### 2.在 manifest 和代码中如何注册和使用 BroadcastReceiver

- 静态注册：

    - 在清单文件中注册广播接收者称为静态注册

    - 静态注册的广播接收者只要 app 在系统中运行则一直可以接收到广播消息

        ```xml
        <application
                     ...>
            <receiver android:name=".MyBroadcastReceiver"
                      android:exported="true"
                      android:enabled="true">
                <intent-filter>
                    <action android:name="android.intent.action.BOOT_COMPLETED" />
                </intent-filter>
            </receiver>
        </application>
        ```
        
        在上面的示例中，我们将 `MyBroadcastReceiver` 注册为接收系统启动完成广播的接收器。我们在 `<intent-filter>` 元素中使用了 `<action>` 元素，以指定我们要接收的广播消息类型。
        
        注意，必须在应用程序的清单文件中声明 `BroadcastReceiver`，以便操作系统可以找到它并将广播消息发送到它。

-   动态注册：

    -   在代码中注册称为动态注册

    -   动态注册的广播接收者当注册的 Activity 或者 Service 销毁了那么就接收不到广播

        ```java
        MyBroadcastReceiver myReceiver = new MyBroadcastReceiver();
        IntentFilter filter = new IntentFilter();
        filter.addAction(Intent.ACTION_POWER_CONNECTED);
        filter.addAction(Intent.ACTION_POWER_DISCONNECTED);
        registerReceiver(myReceiver, filter);
        ```
        
        在上面的示例中，我们使用 `registerReceiver()` 方法动态注册了 `MyBroadcastReceiver` 接收器，它将接收电源连接和断开广播消息。
    
    -   要注销接收器，请使用 `unregisterReceiver()` 方法：
    
        ```java
        unregisterReceiver(myReceiver);
        ```
    
-   发送广播消息

    在发送广播消息时，你需要使用 `Intent` 对象来描述要发送的消息类型。例如，要发送一个自定义的广播消息，你可以编写以下代码：

	```java
Intent intent = new Intent(); 
intent.setAction("com.example.myapp.MY_ACTION");
intent.putExtra("key", "value"); 
sendBroadcast(intent);
	```

    在上面的示例中，我们创建了一个新的 `Intent`，并设置了 `action` 和 `extra` 字段来描述我们要发送的广播消息类型和数据。

-   接收广播消息

	当你的应用程序注册了一个 `BroadcastReceiver` 并且符合该广播消息的条件时，系统将会调用 `BroadcastReceiver` 的 `onReceive()` 方法，让你的应用程序可以响应这个广播消息。
	
	
	
	在 `onReceive()` 方法中，你可以编写你的应用程序响应广播消息的逻辑。例如，如果你的应用程序需要在接收到 `ACTION_POWER_CONNECTED` 广播消息时更新用户界面，则可以编写以下代码：

	```java
	public class MyBroadcastReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        if (action.equals(Intent.ACTION_POWER_CONNECTED)) {
            // 更新用户界面
        }
    }
	}
	```

	在上面的示例中，我们在 `onReceive()` 方法中检查接收到的广播消息类型是否是 `ACTION_POWER_CONNECTED`，如果是，则更新用户界面。

	>   注意，如果你需要在 `BroadcastReceiver` 中执行任何耗时操作，例如网络请求或文件 I/O 操作，请务必将其放在一个单独的线程中，以避免阻塞 UI 线程。

### 3.BroadCastReceiver 的生命周期

它的生命周期方法分别是：

1.  onReceive(): BroadcastReceiver 的核心方法，在接收到广播时被调用。在这个方法中，可以对接收到的广播进行处理。
2.  onAbortBroadcast(): 在接收到广播后，如果需要终止广播的传递，可以调用这个方法。
3.  onReceive(Context context, Intent intent): 这个方法是 BroadcastReceiver 的重载方法，它接收两个参数，第一个参数是 Context，第二个参数是 Intent。在这个方法中，可以通过 Intent 获取广播的信息，并对广播进行处理。
4.  onEnabled(Context context, Intent intent): 当 BroadcastReceiver 被系统启用时调用。
5.  onDisabled(Context context, Intent intent): 当 BroadcastReceiver 被系统禁用时调用。
6.  onRegister(Context context, Intent intent): 当 BroadcastReceiver 被注册时调用。
7.  onUnregister(Context context, Intent intent): 当 BroadcastReceiver 被注销时调用。

**注意**：

1.   广播接收者的生命周期非常短暂的， 在接收到广播的时候创建，onReceive()方法结束之后销毁。
2.   广播接收者中不要做一些耗时的工作， 否则会弹出 Application No Response 错误对话框。
3.   最好也不要在广播接收者中创建子线程做耗时的工作，因为广播接收者被销毁后进程就成为了空进程，很容易被系统杀掉。
4.   耗时的较长的工作最好放在服务中完成。

-   Android中引入广播机制的用意

    Android 引入广播机制的主要目的是为了简化 Android 应用程序之间的通信，以及在同一个应用程序内部的不同组件之间的通信。广播机制也提供了一种轻量级的、异步的、松散耦合的通信方式。
    通过广播机制，一个应用程序可以向所有已注册该广播的应用程序、系统、设备和其他组件发送消息。这使得多个组件可以在不使用复杂的应用程序之间的绑定和纷繁复杂的消息传递协议的情况下共享相同的事件。
    例如，当设备的电池电量发生变化时，系统会发送一个广播消息。所有已注册了该广播的应用程序都将接收到此消息。这使得应用程序可以根据电池电量的变化来调整其行为。
    总之，Android 广播机制简化了 Android 应用程序之间的通信，使得应用程序可以更容易地实现复杂的功能。

    1.   Android 的四大组件本质上就是为了实现移动或者说嵌入式设备上的 MVC 架构，它们之间有时候是一种相互依存的关系，有时候又是一种补充关系，引入广播机制可以方便几大组件的信息和数据交互。
    2.   程序间互通消息(例如在自己的应用程序内监听系统来电)
    3.   效率上(参考 UDP 的广播协议在局域网的方便性)
    4.   设计模式上(反转控制的一种应用，类似监听者模式)



## 四、ContentProvider

### 1.请介绍下 ContentProvider 是如何实现数据共享的（★★★）

-   在 Android 中如果想将自己应用的数据（一般多为数据库中的数据）提供给第三发应用，那么我们只能通过 ContentProvider 来实现了。

-   ContentProvider 是应用程序之间共享数据的接口。使用的时候首先自定义一个类继承 ContentProvider，然后覆写 query、insert、update、delete 等方法。

-   必须在 AndroidManifest 文件中进行注册。

-   把自己的数据通过 uri 的形式共享出去，android 系统下 不同程序 数据默认是不能共享访问，需要去实现一个类去继承 ContentProvider

    ```java
    public class PersonContentProvider extends ContentProvider{
        public boolean onCreate(){
        }
        query(Uri, String[], String, String[], String)
            insert(Uri, ContentValues);
            update(Uri, ContentValues, String, String[]);
            delete(Uri, String, String[]);
    }
    ```

    ```xml
    <provider android:exported="true"
              android:name="com.itheima.contenProvider.provider.PersonContentPro vider"
              android:authorities="com.itheima.person"  />
    ```

    第三方可以通过 ContentResolver 来访问该 Provider。

### 2.为什么要用 ContentProvider？它和 sql 的实现上有什么差别？（★★★）

-   ContentProvider 屏蔽了数据存储的细节,内部实现对用户完全透明,用户只需要关心操作数据的 uri 就可以了，ContentProvider 可以实现不同 app 之间共享。
    Sql 也有增删改查的方法， 但是 sql 只能查询本应用下的数据库。而
    ContentProvider 还可以去增删改查本地文件. xml 文件的读取等。

-   ContentProvider主要是为了支持多个应用程序之间共享数据而设计的，而SQL主要是为了支持单个应用程序内的数据管理而设计的。此外，ContentProvider还提供了一些额外的功能，如**数据权限管理**和**数据URI**的支持，使应用程序可以更轻松地访问共享数据。

### 3.说说 ContentProvider、ContentResolver、ContentObserver之间的关系（★★★★）

ContentProvider、ContentResolver、ContentObserver是Android中用于实现跨应用程序数据共享的三个核心类，它们之间的关系如下：

1.  ContentProvider：用于在应用程序之间共享数据，可以将数据存储在数据库中或者以文件形式存储在磁盘上。ContentProvider会提供一些标准的CRUD操作（创建、读取、更新和删除）以及查询接口，其他应用程序通过**ContentResolver对象调用ContentProvider的接口**来访问数据。
2.  ContentResolver：用于在应用程序之间访问ContentProvider提供的数据。ContentResolver对象可以通过调用ContentProvider提供的接口实现数据的增删改查操作，并且可以**通过注册ContentObserver来监听数据的变化**。
3.  ContentObserver：用于监视ContentProvider中的数据变化，当数据发生变化时，ContentObserver会收到通知并触发回调函数。**其他应用程序可以通过ContentResolver注册ContentObserver来监听数据的变化**，从而实现实时更新数据的效果。

综上所述，ContentProvider是提供数据的地方，ContentResolver是访问数据的地方，而ContentObserver是用于监听数据变化的地方。它们三者配合使用可以实现应用程序之间数据的共享和实时更新。

### 4.如何使用 contentProvider 获取本地所有的音频文件（★★★）

Android 中，系统为多媒体类型的文件（比如图片、音频、视频等）建立了数据库(sqlite 数据库)，将文件的名称、大小等信息存储起来，从而完成多媒体数据的维护工作。

要使用ContentProvider获取本地所有的音频文件，可以执行以下步骤：

1.  获取ContentResolver对象，这个对象是用于和ContentProvider通信的接口。

```java
ContentResolver resolver = context.getContentResolver();
```

2.  构建查询的URI和投影（projection）数组，这个URI指向音频文件的存储位置，投影数组用于指定我们需要查询的列。

```java
Uri uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;
String[] projection = {
        MediaStore.Audio.Media._ID,
        MediaStore.Audio.Media.TITLE,
        MediaStore.Audio.Media.ARTIST,
        MediaStore.Audio.Media.DATA
};
```

3.  使用ContentResolver的query方法查询音频文件数据，该方法返回一个Cursor游标对象，其中包含了查询结果。

```java
Cursor cursor = resolver.query(uri, projection, null, null, null);
```

4.  遍历Cursor对象，从中获取音频文件的信息，例如文件名、路径、时长等。

```java
while(cursor.moveToNext()) {
    String title = cursor.getString(cursor.getColumnIndex(MediaStore.Audio.Media.TITLE));
    String artist = cursor.getString(cursor.getColumnIndex(MediaStore.Audio.Media.ARTIST));
    String path = cursor.getString(cursor.getColumnIndex(MediaStore.Audio.Media.DATA));
    long duration = cursor.getLong(cursor.getColumnIndex(MediaStore.Audio.Media.DURATION));
    // TODO: 处理获取到的音频文件信息
}
```

5.  最后，在使用完Cursor对象后，需要调用它的close方法关闭游标。

```java
cursor.close();
```

综上所述，通过以上步骤，可以使用ContentProvider获取本地所有的音频文件，并从中提取所需信息。需要注意的是，由于查询可能会返回大量数据，因此最好将查询放在异步线程中执行，以免阻塞UI线程。

同时因为是从本地读取数据，所以需要添加权限:
```xml 
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
```



## 五、 ListView

### 1.ListView 如何提高其效率？

-   复用ConvertView，使用历史的view
-   自定义静态类ViewHolder，减少findViewById 的次数
-   **异步加载数据**，**分页加载数据**
-   使用WeakRefrence 引用ImageView对象

### 2.当 ListView 数据集改变后，如何更新 ListView

使用该 ListView 的 adapter 的 `notifyDataSetChanged()`方法。该方法会使 ListView 重新绘制。

### 3.ListView 如何实现分页加载（★★★★★）

在 ListView 中添加滑动监听器。只关心静止状态：当滑动状态为 `SCROLL_STATE_IDLE`（即空闲状态）且滑动到底部时，触发分页加载的操作，关心最后一个可见的条目，如果最后一个可见条目就是数据适配器（集合）里的最后一个，此时可加载更多的数据。在每次加载的时候，计算出滚动的数量，当滚动的数量大于等于总数量的时候，可以提示用户无更多数据了。

### 4.ListView 可以显示多种类型的条目吗（★★）

是的，ListView 可以显示多种类型的条目。这通常称为多布局类型列表或多类型列表。

实现多类型列表的关键在于让 ListView 的 Adapter 可以处理多个不同类型的数据，并根据数据类型的不同，显示对应的条目布局。

一种实现方式是通过重写 Adapter 中的 getViewTypeCount 和 getItemViewType 方法。其中，getViewTypeCount 方法用于返回 ListView 中不同类型的视图的总数，而 getItemViewType 方法则用于返回指定位置上的数据项所使用的视图类型。在 getView 方法中，根据 getItemViewType 返回的视图类型，选择对应的布局来显示数据。

另一种实现方式是通过 RecyclerView 来实现多类型列表，其中 RecyclerView 中的 Adapter 支持多类型条目的显示，并且性能比 ListView 更好。RecyclerView 的实现方式类似于 ListView，需要重写 getItemViewType 和 onCreateViewHolder 方法，并在 onCreateViewHolder 方法中返回对应的 ViewHolder。

### 5.ListView 如何定位到指定位置

1.  ListView 定位到指定位置

（1）使用 `setSelection()` 方法

setSelection 方法可以让 ListView 滚动到指定位置，其中参数 position 表示要定位的位置。

例如，使用以下代码可以将 ListView 定位到第 10 个位置：

```java
listView.setSelection(9);
```

（2）使用 `smoothScrollToPosition()` 方法

smoothScrollToPosition 方法可以平滑地滚动到指定位置。

例如，使用以下代码可以让 ListView 平滑地滚动到第 10 个位置：

```java
listView.smoothScrollToPosition(9);
```

1.  RecyclerView 定位到指定位置

RecyclerView 中定位到指定位置的方法与 ListView 有所不同。通常使用以下方法来实现：

（1）使用 `scrollToPosition()` 方法

scrollToPosition 方法可以将 RecyclerView 定位到指定位置，其中参数 position 表示要定位的位置。

例如，使用以下代码可以将 RecyclerView 定位到第 10 个位置：

```java
recyclerView.scrollToPosition(9);
```

（2）使用 `smoothScrollToPosition()` 方法

smoothScrollToPosition 方法可以平滑地滚动到指定位置。

例如，使用以下代码可以让 RecyclerView 平滑地滚动到第 10 个位置：

```java
recyclerView.smoothScrollToPosition(9);
```

需要注意的是，RecyclerView 中的布局管理器可能会影响 scrollToPosition 和 smoothScrollToPosition 方法的表现。例如，LinearLayoutManager 支持垂直和水平滚动，而 GridLayoutManager 则支持网格布局。因此，在使用 RecyclerView 定位到指定位置时，需要注意当前使用的布局管理器是否支持相应的滚动方式。

### 6.如何在ScrollView 中如何嵌入 ListView（★★★★）

-   通常情况下我们不会在 ScrollView 中嵌套 ListView，但是如果必须嵌套的话也是可以的。
-   在 ScrollView 添加一个 ListView 会导致 listview 控件显示不全，通常只会显示一条，这是因为两个控件的滚动事件冲突导致。需要通过 listview 中的item 数量去计算 listview 的显示高度，从而使其完整展示。

### 7.ListView、RecyclerView 中如何优化图片（★★）

在 RecyclerView 中优化图片主要有以下几种方法：

1.  使用图片压缩

使用图片压缩可以减小图片的文件大小，从而减少内存的消耗。常用的图片压缩方法包括使用压缩库如 Luban、Tiny、Glide 等对图片进行压缩，或者使用 BitmapFactory.Options 对图片进行压缩处理。

2.  使用图片缓存

在加载图片时，使用图片缓存可以减少重复加载同一张图片的次数，从而提高图片加载速度，并减少内存的消耗。常用的图片缓存库包括 Glide、Picasso、Fresco 等。

3.  使用图片裁剪

使用图片裁剪可以将图片的大小裁剪为合适的尺寸，以适应显示的控件大小。可以使用 Glide、Picasso 等图片加载库中的裁剪方法，或者使用 BitmapFactory 对图片进行裁剪处理。

4.  延迟加载

可以使用 RecyclerView 中的 onScrollStateChanged 方法监听 RecyclerView 的滑动状态，并在滑动停止时才加载图片，从而减少内存的消耗。

5.  优化 ViewHolder

ViewHolder 是 RecyclerView 中用于缓存布局中各个视图的类。在 ViewHolder 中，可以使用 findViewById 方法对布局中的各个视图进行缓存，从而减少 findViewById 方法的调用次数，提高布局的加载速度。

综上所述，为了在 RecyclerView 中优化图片，需要使用图片压缩、图片缓存、图片裁剪、延迟加载等方法，并优化 ViewHolder 类的实现。

























