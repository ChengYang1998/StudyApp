# Android八股文 - Chip - 2023

# 第一章：Android 基础

## 一、Activity

### 1.什么是activity？

- 四大组件之一

- Context 子类
- 实现了 window.callback 和 keyevent.callback ，可以处理窗体与用户交互的事件
- 开发常用：FragmentActivity、TabActivity、ListActivity

### 2.请描述Activity生命周期

- Activity从创建到销毁有多种状态，从一种状态到另一种状态时会激发相应的回调方法。

包括：onCreate创建 onStart可见 onResume焦点 onPause不可编辑 onStop不可见 onDestroy销毁

这些方法两两对应。

### 3.Activity生命周期

### 4.保存 Activity 的状态或者（ Activity 重启怎么保存数据？）

- Activity 的状态通常情况下系统会自动保存的，只有当我们需要保存额外的数据时才需要使用到这样的功能。

- 通常：调用`onPause()`和`onStop()`方法后的activity 实例仍然存在于内存中，activity 的所有信息和状态数据不会消失，当 activity
  重新回到前台之后，所有的改变都会得到保留。

- 内存不足时：调用`onPause()`和`onStop()`方法后的activity 可能会被系统摧毁，activity 重新回到前台, 之前所作的改变就会消失。
- 解决方法：可以覆写 `onSaveInstanceState()`方法，他接受一个 Bundle 类型的参数, 开发者可以将状态数据存储到这个 Bundle 对象中，在 onPause()或
  onStop()方法之前调用 `onSaveInstanceState()`。重新启动这个 activity 而调用它的`onCreate()`方法时, 上述的Bundle
  对象会作为实参传递给 `onCreate()`方法，开发者可以从 Bundle 对象中取出保存的数据, 然后利用这些数据将 activity 恢复到被摧毁之前的状态。

- 注意：用户按下 BACK 键退出 activity 时, 用户显然想要关闭这个 activity，`onSaveInstanceState()`方法不会被调用。

```java
@Override
protected void onSaveInstanceState(Bundle outState){
// TODO Auto-generated method stub
        super.onSaveInstanceState(outState);
        }
```

### 5、 两个 Activity 之间跳转时必然会执行的是哪几个方法？

- 当Activity **A**跳转到**B**时，**A**会调用onPause()方法，然后**B**调用onCreate(),onStart(),onResume()方法。
- 如果**B**覆盖了窗体，**A**会调用onStop()方法；如果**B**是透明的或者是个对话框，**A**不会调用onStop()方法。

### 6、 横竖屏切换时Activity 的生命周期（★★★★）

activity 在配置更改时（如屏幕方向、键盘可用性、语言、屏幕大小等）和**清单文件里的配置**有关系。

- 不设置 Activity 的 android:configChanges 时，切屏会重新调用各个生命周期默认首先销毁当前 activity,然后重新加载。
- 当 android:configChanges 属性设置了某些选项时，每次发生对应的更改时，Android 系统不再销毁并重新创建该 activity，而是会调用该 activity
  的 `onConfigurationChanged()` 方法。因此，在该方法中，开发者需要自行处理相关的逻辑以适应新的配置状态。

### 7、 如何将一个 Activity 设置成窗口的样式

将 Activity 配置如下属性即可。

android:theme="@android:style/Theme.Dialog"

### 8、 如何退出 Activity ？ 如何安全退出已调用多个Activity 的 Application？（★★★★）

1. 用户：退出一个 Activity 只需按返回键

   开发者：调用`finish()`

2. 递归退出
   在打开新的 Activity 时使用 startActivityForResult，然后自己加标志，在onActivityResult 中处理，递归关闭。


3. 记录打开的 Activity：

   维护一个Activity List记录打开的每一个Activity，在需要退出时，循环finish每一个 Activity 即可。

```java
List<Activity> lists;// 在 application 全局的变量里面
        lists=new ArrayList<Activity>();
        lists.add(this);
        for(Activity activity:lists){
        activity.finish();
        }
        lists.remove(this);
```

4. 发送特定广播：

   在需要结束应用时，发送一个特定的广播，每个 Activity 收到广播后，关闭即可。

   ```java
   //给某个 activity 注册接受接受广播的意图
   registerReceiver(receiver, filter)
   //如果接受到 关闭 activity 的广播 就调用 finish() 方法 把当前的 activity finish()掉
   ```

5. 通过 intent 的 flag 来实现

```java
intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
```

- 激活一个新的 activity，此时会把该任务栈中这个 Activity 上面的所有Activity 清除。

- 相当于给 Activity 配置的启动模式为 SingleTop。

### 9、 Activity 的 四 种 启 动 模 式 ， singletop 和singletask 区别是什么？一般书签的使用模式是 singletop ，那为什么不使用  singletask ?

- singleTop 跟 standard 模式比较类似。**唯一的区别**就是：

  当跳转的对象是位于栈顶的 activity（应该可以理解为用户眼前所 看到的 activity）时，程序**将不会生成一个新的activity 实例**，而是直接跳到现存于栈顶的那个
  activity 实例。拿上面的例子来说，当 Act1 为 singleTop 模式时，执行跳转后栈里面依旧只有一个实例，如果现在按返回键程序将直接退出。

- singleTask 模式和 singleInstance 模式都是只创建一个实例的。在这种模式下，若栈里面已经有这个实例，无论跳转的对象是不是位于栈顶的
  activity，程序都不会生成一个新的实例。指定singleInstance模式的Activity会启用一个新的返回栈来管理这个Activity。

- 在一般情况下，使用 singleTop 模式是比较合适的，因为使用这种模式可以避免很多意外情况，相比之下，使用 singleTask 模式需要考虑更多的因素，因此并不是所有的场景都适用。比如：使用
  singleTask 模式时，当在一个 task 中已经存在目标 Activity 的实例时，操作返回时栈顶会将中间的所有 Activity
  移除，从而可能导致一系列操作后得到的返回结果不一致，需要进行特殊处理。

### 10、Android 中的 Context, Activity，Application 有什么区别？（★★）

- 相同点：Activity和Application都是Context的子类。

- Context指上下文的意思，实际应用中起**管理上下文环境中各个参数各变量的作用**，方便我们可以简单的访问到各种资源。

- 不同点：维护的生命周期不同：

  Context维护的是当前Activity的生命周期，Application维护的是整个项目的生命周期。

- 使用 context 的时候，要防止内存泄露，需要注意一下几个方面：

    1. 不要让生命周期长的对象引用 activity context，即保证引用 activity 的对象要与 activity 本身生命周期是一样的。
    2. 对于生命周期长的对象，可以使用 application，context。
    3. 避免非静态的内部类，**尽量使用静态类**，避免生命周期问题，注意内部类对外部对象引用导致的生命周期变化。

### 11、两个Activity 之间传递数据，除了 intent，广播接收者，content provider 还有那些方法？

1. static静态数据，public static 成员变量
2. 利用外部存储的传输， 例如：File 文件存储、SharedPreferences 轻量级的存储类、Sqlite 数据库

### 12、Context 是 什 么 ？ ， 一 个 应 用 有 多 少 个 Context(2020.5.15）（★★）

1. 它描述的是一个应用程序环境的信息，即上下文，起**管理上下文环境中各个参数各变量的作用**，方便我们可以简单的访问到各种资源。
2. 该类是一个抽象(abstract class)类，Android 提供了该抽象类的具体实现类（ContextIml）。
3. 通过它我们可以获取应用程序的资源和类，也包括一些应用级别操作， 例如：启动一个 Activity，发送广播，接受 Intent，信息等。
4. **一个应用 Context 数量**=**Activity 个数** + **service 个数** + 1 个

### 13.activity 之间还有 activity 和 service 之间如何传值，可以传图片吗？

- Activity 之间传值：

  使用Intent：通过 Intent 对象的各种 putExtra 方法来进行传递。在第二个 Activity 对象中，可以通过 `getIntent()` 方法来得到跳转到这个 Activity
  的 Intent 对象，然后通过 Intent 对象的各种 getXXExtra 方法来得到我们的传过来的值。

- Activity 和 Service 之间传值：

    1. 通过 `startService（intent）`使用Intent传值。

       此时需要在清单文件中注册这个Service

  ```xml
  <service Android:enabled="true" android:name=".Service">
  </service>
  ```

    2. Service 可以从 `public int onStartCommand(Intent intent, int flags, int startId)`中取出从 activity
       中传过来的值。`intent.getExtra()`获得 bundle 对象， 可从中取值。

    3. Activity 也可以用 bindService(intent, conn,BIND_AUTO_CREATE);传值，把要传的值绑定在 intent 里，在 service
       的 `public IBinder onBind(Intent intent)` 方法里取得 intent 。
    4. 可以在 receiver 里面注册一个广播，在 activity 里`sendbroadcast(intent)`传值。

- 可以传递图片：用 Intent 把**图片的地址**或者把**图片对象**用 Intent 传过去，用**bitmap** 对象。

## 二、Service

### 1.Service是否在main thread中执行，Service里面是否能执行耗时操作？（★★）

- 若未显式声明Service所运行的进程，Service和Activity是运行在当前app所在进程的main thread（UI主线程）里面。

  不可执行耗时操作，如：网络请求、拷贝数据库、大文件

- 可以在清单文件中配置Service执行所在的进程，让Service在另外的进程中执行

  ```xml
  <service
  	android:name="com.baidu.location.f" 
  	android:enabled="true" 
  	android:process=":remote" >
  </service>
  ```

### 2.Activity怎么和Service绑定，怎么在Activity中启动自己对应的Service？

- Activity通过`bindService(Intent service,ServiceConnection conn,int flags)`
  同Service进行绑定，当绑定成功的时候Service会将代理对象通过回调的形式传给conn，就可以拿到Service提供的服务代理对象。
- 可以通过startService和bindService启动Service。想获取Service的服务对象，需要`bindService()`方法，如音乐播放器或第三方支付。
- 如果仅仅为了开启一个后台任务可以使用startService()方法。

### 3.描述Service的生命周期（★★★）

Service有非绑定模式、绑定模式、这两种的混合方式。不同使用方法生命周期不同。

- 非绑定模式：第一次调用startService的时候，执行方法依次为：`onCreate()`、`onStartCommand()`，当Service关闭的时候调用`onDestory()`方法。
- 绑定模式：第一次调用bindService()的时候，执行方法依次为：`onCreate()`、`onBind()`，解除绑定的时候会执行 `onUnbind()`、`onDestory()`。

> 上面的两种生命周期是在相对单纯的模式下的情形。我们在开发的过程中还必须注意 Service 实例只会有一个，也就是说如果当前要启动的 Service 已经存在了那么就不会再次创建该 Service
> 当然也不会调用 onCreate（）方法。
>



> 一个 Service 可以被多个客户进行绑定，只有所有的绑定对象都执行了
> onBind（）方法后该 Service 才会销毁，不过如果有一个客户执行了 onStart() 方法，那么这个时候如果所有的 bind 客户都执行了 unBind()该 Service
> 也不会销毁。



<img src="https://cdn.jsdelivr.net/gh/ChengYang1998/blogImage@main/PicGo/image-20230322103750747.png" alt="image-20230322103750747" style="zoom:67%;" />

### 4.什么是IntentService？有何优点？（★★★）

> 我们通常只会使用 Service，可能 IntentService
> 对大部分同学来说都是第一次听说。那么看了下面的介绍相信你就不再陌生了。如果你还是不了解那么在面试的时候你就坦诚说没用过或者不了解等。并不是所有的问题都需要回答上来的。

1. IntentService简介

    - IntentService是Service的子类，比普通Service增加了额外的功能

    - Service 本身存在两个问题：
        1. Service 不会专门启动一条单独的进程，Service 与它所在应用位于同一个进程中
        2. Service 也不是专门一条新线程，因此不应该在 Service 中直接处理耗时的任务


2. IntentService特征

    - 会创建独立的worker线程来处理**所有的Intent请求**

    - 会创建独立的worker线程来处理`onHandleIntent()`方法实现的代码，无需处理多线程问题

    - 所有请求处理完成后，IntentService 会自动停止，无需调用 stopSelf()方法停止 Service

    - 为 Service 的 `onBind()`提供默认实现，返回 null

    - 为 Service 的 `onStartCommand()` 提供默认实现，将请求 Intent 添加到队列中

3. 使用 IntentService

   IntentService使用例。

    - MainActivity.java:

   ```java
   public void click(View view) {
   	Intent intent = new Intent(this, MyIntentService.class); 					intent.putExtra("start", "MyIntentService"); 
       startService(intent);
   }
   ```
    - MyIntentService.java

   ```java
   public class MyIntentService extends IntentService {
   	private String ex = "";
       private Handler mHandler = new Handler() {
           public void handleMessage(android.os.Message msg) {
               Toast.makeText(MyIntentService.this, "-e " + ex,Toast.LENGTH_LONG).show();
           }
       };
       
       public MyIntentService() { 
           super("MyIntentService");
       }
   
    
       @Override
       public int onStartCommand(Intent intent, int flags, int startId) { 
           ex = intent.getStringExtra("start");
           return super.onStartCommand(intent, flags, startId);
       }
   
      /**
   		* 模拟执行耗时任务
   		* 该方法是在子线程中执行的，因此需要用到 handler 跟主线程进行通信
   		*/
       @Override
       protected void onHandleIntent(Intent intent) {
        
           try {
               Thread.sleep(1000);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
           mHandler.sendEmptyMessage(0);
           try {
               Thread.sleep(1000);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
       }
   }
   ```

### 5.Activity、Intent、Service关系

- Activity、Service是四大组件之一，都是 Context 类的子类ContextWrapper 的子类。
- Activity 负责用户界面的显示和交互，Service 负责后台任务的处理。
- Activity 和 Service 之间可以通过 Intent 传递数据。

### 6.Service 和Activity 在同一个线程吗（★）

未显式声明的情况下都在UI线程。

### 7.Service 里面可以弹吐司么（★）

可以的。弹吐司有个条件就是得有一个 Context 上下文，而 Service 本身就是 Context 的子类，因此在 Service 里面弹吐司是完全可以的。比如我们在Service
中完成下载任务后可以弹一个吐司通知用户。

### 8.什么是 Service 以及描述下它的生命周期。Service 有哪些启动方法，有什么区别，怎样停用Service？（★★★）

在Service 的生命周期中，被回调的方法比 Activity 少一些，只有 onCreate, onStart, onDestroy,
onBind 和 onUnbind。
通常有两种方式启动一个 Service,他们对 Service 生命周期的影响是不一样的。

1. 通过 startService
   Service 会经历 onCreate 到 onStart，然后处于运行状态，stopService 的时候调用 onDestroy 方法。
   如果是调用者自己直接退出而没有调用 stopService 的话，Service 会一直在后台运行。
2. 通过 bindService
   Service会运行onCreate，然后是调用onBind，这个时候调用者和Service绑定在一起。调用者退出了，Service 就会调用 onUnbind->onDestroyed 方法。

所谓绑定在一起就共存亡了。调用者也可以通过调用 unbindService 方法来停止服务，这时候 Service 就会调用 onUnbind -> onDestroyed 方法。

如果这几个方法交织在一起的话，会出现什么情况？

- 一个原则是 Service 的 **onCreate 的方法只会被调用一次**，就是你无论多少次的startService 又 bindService，Service 只被创建一次。
- 如果先是 bindService 了，那么 start 的时候就直接运行 Service 的 onStart 方法， 如果先是 startService ，那么 bind 的时候就直接运行
  onBind 方法。
- 如果 service 运行期间调用了 bindService，这时候再调用 stopService 的话，service 是不会调用 onDestroy 方法的，service 就 stop
  不掉了，只能调用UnbindService, service 就会被销毁
- 如果一个 service 通过 startService 被 start 之后，多次调用 startService的话，service 会多次调用 onStart 方法。多次调用
  stopService 的话，service 只会调用一次 onDestroyed 方法。
- 如果一个 service 通过 bindService 被 start 之后，多次调用 bindService 的话，service 只会调用一次 onBind 方法。**多次调用
  unbindService 的话会抛出异常**。

### 9.在Service的生命周期方法onStartCommand()可不可以执行网络操作？如何在Service中执行网络操作？

可以在 `onStartCommand()` 方法中执行网络操作，但需要注意一些细节。

在执行网络操作时，需要在一个独立的线程中进行，以避免在主线程中阻塞。因此，在 `onStartCommand()` 中启动一个新的线程，并在该线程中执行网络操作是一个好的选择。

以下是一个示例，说明如何在 Service 中执行网络操作：

```java
public class MyService extends Service {
    private Thread mThread;

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        mThread = new Thread(() -> {
            // 在这里执行网络操作
            // ...

            // 在完成操作后，调用stopSelf()以停止服务
            stopSelf();
        });
        mThread.start();
        return START_NOT_STICKY;
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        if (mThread != null) {
            mThread.interrupt();
        }
    }

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }
}

```

在上面的示例中，我们在 `onStartCommand()` 方法中创建一个新的线程，并在其中执行网络操作。在完成操作后，我们调用 `stopSelf()`
方法以停止服务。在 `onDestroy()` 方法中，我们中断线程，以确保线程在服务销毁时被正确地终止。

## 三、Broadcast Receiver

### 1.请描述一下 BroadcastReceiver（★★）

-

定义：BroadcastReceiver是Android应用程序中的一个组件，用于接收系统或app发送的广播消息，并根据需要执行相应的操作。广播消息是一种用于应用程序间通信和事件传递的机制，可以在应用程序内部、跨应用程序和系统级别上发送和接收广播消息。
-
BroadcastReceiver实现了一个特定的Java接口，并在应用程序的清单文件中注册，并且声明它所匹配的广播消息类型。当一个匹配的广播消息被发送时，系统将自动调用BroadcastReceiver的`onReceive()`
方法，其中包含接收到的广播消息的信息。开发人员可以根据需要在`onReceive()`方法中编写自己的代码，例如启动服务、更新UI等等。

- 广播分两种：**有序广播**和**无序广播**。
- 内部通信实现机制：通过 Android 系统的 **Binder** 机制实现通信。
- 无序广播：完全异步，逻辑上可以被任何广播接收者接收到。优点是效率较高。缺点是一个接收者不能将处理结果传递给下一个接收者，并无法终止广播 intent 的传播。
- 有序广播：按照被接收者的优先级顺序，在被接收者中依次传播。比如有三个广播接收者 A，B，C，优先级是 A > B > C。那这个消息先传给 A，再传给 B，最后传给
  C。每个接收者有权终止广播，比如 B 终止广播，C 就无法接收到。此外 A 接收到广播后可以对结果对象进行操作，当广播传给 B 时，B 可以从结果对象中取得 A 存入的数据。

通过 `Context.sendOrderedBroadcast(intent, receiverPermission,resultReceiver, scheduler, initialCode, initialData, initialExtras)`
可以指定 resultReceiver 广播接收者，这个接收者认为是最终接收者。通常情况下如果比他优先级更高的接收者如果没有终止广播，那么他的`onReceive()`会被**执行两次**
。第一次是正常的**按照优先级顺序执行**，第二次是**作为最终接收者接收**（如果比他优先级高的接收者终止了广播，那么他依然能接收到广播）。

- 例如：在我们的项目中经常使用广播接收者接收系统通知，比如开机启动、sd 挂载、低电量、外播电话、锁屏，如果我们做的是播放器，那么监听到用户锁屏后我们应该将我们的播放暂停。

### 2.在 manifest 和代码中如何注册和使用 BroadcastReceiver

- 静态注册：

    - 在清单文件中注册广播接收者称为静态注册

    - 静态注册的广播接收者只要 app 在系统中运行则一直可以接收到广播消息

        ```xml
        <application
                     ...>
            <receiver android:name=".MyBroadcastReceiver"
                      android:exported="true"
                      android:enabled="true">
                <intent-filter>
                    <action android:name="android.intent.action.BOOT_COMPLETED" />
                </intent-filter>
            </receiver>
        </application>
        ```

      在上面的示例中，我们将 `MyBroadcastReceiver` 注册为接收系统启动完成广播的接收器。我们在 `<intent-filter>` 元素中使用了 `<action>`
      元素，以指定我们要接收的广播消息类型。

      注意，必须在应用程序的清单文件中声明 `BroadcastReceiver`，以便操作系统可以找到它并将广播消息发送到它。

- 动态注册：

    - 在代码中注册称为动态注册

    - 动态注册的广播接收者当注册的 Activity 或者 Service 销毁了那么就接收不到广播

      ```java
      MyBroadcastReceiver myReceiver = new MyBroadcastReceiver();
      IntentFilter filter = new IntentFilter();
      filter.addAction(Intent.ACTION_POWER_CONNECTED);
      filter.addAction(Intent.ACTION_POWER_DISCONNECTED);
      registerReceiver(myReceiver, filter);
      ```

      在上面的示例中，我们使用 `registerReceiver()` 方法动态注册了 `MyBroadcastReceiver` 接收器，它将接收电源连接和断开广播消息。

    - 要注销接收器，请使用 `unregisterReceiver()` 方法：

      ```java
      unregisterReceiver(myReceiver);
      ```

- 发送广播消息

  在发送广播消息时，你需要使用 `Intent` 对象来描述要发送的消息类型。例如，要发送一个自定义的广播消息，你可以编写以下代码：

  ```java
  Intent intent = new Intent();
  intent.setAction("com.example.myapp.MY_ACTION");
  intent.putExtra("key", "value");
  sendBroadcast(intent);
  ```

  在上面的示例中，我们创建了一个新的 `Intent`，并设置了 `action` 和 `extra` 字段来描述我们要发送的广播消息类型和数据。

- 接收广播消息

  当你的应用程序注册了一个 `BroadcastReceiver` 并且符合该广播消息的条件时，系统将会调用 `BroadcastReceiver` 的 `onReceive()`
  方法，让你的应用程序可以响应这个广播消息。

  在 `onReceive()` 方法中，你可以编写你的应用程序响应广播消息的逻辑。例如，如果你的应用程序需要在接收到 `ACTION_POWER_CONNECTED`
  广播消息时更新用户界面，则可以编写以下代码：

  ```java
  public class MyBroadcastReceiver extends BroadcastReceiver {
  @Override
  public void onReceive(Context context, Intent intent) {
      String action = intent.getAction();
      if (action.equals(Intent.ACTION_POWER_CONNECTED)) {
            doSomething();
          // 更新用户界面
      }
  }
  }
  ```

  在上面的示例中，我们在 `onReceive()` 方法中检查接收到的广播消息类型是否是 `ACTION_POWER_CONNECTED`，如果是，则更新用户界面。

  > 注意，如果你需要在 `BroadcastReceiver` 中执行任何耗时操作，例如网络请求或文件 I/O 操作，请务必将其放在一个单独的线程中，以避免阻塞 UI 线程。

### 3.BroadCastReceiver 的生命周期

它的生命周期方法分别是：

1. onReceive(): BroadcastReceiver 的核心方法，在接收到广播时被调用。在这个方法中，可以对接收到的广播进行处理。
2. onAbortBroadcast(): 在接收到广播后，如果需要终止广播的传递，可以调用这个方法。
3. onReceive(Context context, Intent intent): 这个方法是 BroadcastReceiver 的重载方法，它接收两个参数，第一个参数是
   Context，第二个参数是 Intent。在这个方法中，可以通过 Intent 获取广播的信息，并对广播进行处理。
4. onEnabled(Context context, Intent intent): 当 BroadcastReceiver 被系统启用时调用。
5. onDisabled(Context context, Intent intent): 当 BroadcastReceiver 被系统禁用时调用。
6. onRegister(Context context, Intent intent): 当 BroadcastReceiver 被注册时调用。
7. onUnregister(Context context, Intent intent): 当 BroadcastReceiver 被注销时调用。

**注意**：

1. 广播接收者的生命周期非常短暂的， 在接收到广播的时候创建，onReceive()方法结束之后销毁。
2. 广播接收者中不要做一些耗时的工作， 否则会弹出 Application No Response 错误对话框。
3. 最好也不要在广播接收者中创建子线程做耗时的工作，因为广播接收者被销毁后进程就成为了空进程，很容易被系统杀掉。
4. 耗时的较长的工作最好放在服务中完成。

- Android中引入广播机制的用意

  Android 引入广播机制的主要目的是为了简化 Android 应用程序之间的通信，以及在同一个应用程序内部的不同组件之间的通信。广播机制也提供了一种轻量级的、异步的、松散耦合的通信方式。
  通过广播机制，一个应用程序可以向所有已注册该广播的应用程序、系统、设备和其他组件发送消息。这使得多个组件可以在不使用复杂的应用程序之间的绑定和纷繁复杂的消息传递协议的情况下共享相同的事件。
  例如，当设备的电池电量发生变化时，系统会发送一个广播消息。所有已注册了该广播的应用程序都将接收到此消息。这使得应用程序可以根据电池电量的变化来调整其行为。
  总之，Android 广播机制简化了 Android 应用程序之间的通信，使得应用程序可以更容易地实现复杂的功能。

    1. Android 的四大组件本质上就是为了实现移动或者说嵌入式设备上的 MVC
       架构，它们之间有时候是一种相互依存的关系，有时候又是一种补充关系，引入广播机制可以方便几大组件的信息和数据交互。
    2. 程序间互通消息(例如在自己的应用程序内监听系统来电)
    3. 效率上(参考 UDP 的广播协议在局域网的方便性)
    4. 设计模式上(反转控制的一种应用，类似监听者模式)

## 四、ContentProvider

### 1.请介绍下 ContentProvider 是如何实现数据共享的（★★★）

- 在 Android 中如果想将自己应用的数据（一般多为数据库中的数据）提供给第三发应用，那么我们只能通过 ContentProvider 来实现了。

- ContentProvider 是应用程序之间共享数据的接口。使用的时候首先自定义一个类继承 ContentProvider，然后覆写 query、insert、update、delete
  等方法。

- 必须在 AndroidManifest 文件中进行注册。

- 把自己的数据通过 uri 的形式共享出去，android 系统下 不同程序 数据默认是不能共享访问，需要去实现一个类去继承 ContentProvider

  ```java
  public class PersonContentProvider extends ContentProvider{
      public boolean onCreate(){
      }
      query(Uri, String[], String, String[], String)
          insert(Uri, ContentValues);
          update(Uri, ContentValues, String, String[]);
          delete(Uri, String, String[]);
  }
  ```

  ```xml
  <provider android:exported="true"
    android:name="com.itheima.contentProvider.provider.PersonContentProvider"
    android:authorities="com.itheima.person" />
  ```

第三方可以通过 ContentResolver 来访问该 Provider。

### 2.为什么要用 ContentProvider？它和 sql 的实现上有什么差别？（★★★）

- ContentProvider 屏蔽了数据存储的细节,内部实现对用户完全透明,用户只需要关心操作数据的 uri 就可以了，ContentProvider 可以实现不同 app 之间共享。
  Sql 也有增删改查的方法， 但是 sql 只能查询本应用下的数据库。而
  ContentProvider 还可以去增删改查本地文件. xml 文件的读取等。

-

ContentProvider主要是为了支持多个应用程序之间共享数据而设计的，而SQL主要是为了支持单个应用程序内的数据管理而设计的。此外，ContentProvider还提供了一些额外的功能，如**
数据权限管理**和**数据URI**的支持，使应用程序可以更轻松地访问共享数据。

### 3.说说 ContentProvider、ContentResolver、ContentObserver之间的关系（★★★★）

ContentProvider、ContentResolver、ContentObserver是Android中用于实现跨应用程序数据共享的三个核心类，它们之间的关系如下：

1.

ContentProvider：用于在应用程序之间共享数据，可以将数据存储在数据库中或者以文件形式存储在磁盘上。ContentProvider会提供一些标准的CRUD操作（创建、读取、更新和删除）以及查询接口，其他应用程序通过**
ContentResolver对象调用ContentProvider的接口**来访问数据。

2.

ContentResolver：用于在应用程序之间访问ContentProvider提供的数据。ContentResolver对象可以通过调用ContentProvider提供的接口实现数据的增删改查操作，并且可以**
通过注册ContentObserver来监听数据的变化**。

3. ContentObserver：用于监视ContentProvider中的数据变化，当数据发生变化时，ContentObserver会收到通知并触发回调函数。**
   其他应用程序可以通过ContentResolver注册ContentObserver来监听数据的变化**，从而实现实时更新数据的效果。

综上所述，ContentProvider是提供数据的地方，ContentResolver是访问数据的地方，而ContentObserver是用于监听数据变化的地方。它们三者配合使用可以实现应用程序之间数据的共享和实时更新。

### 4.如何使用 contentProvider 获取本地所有的音频文件（★★★）

Android 中，系统为多媒体类型的文件（比如图片、音频、视频等）建立了数据库(sqlite 数据库)，将文件的名称、大小等信息存储起来，从而完成多媒体数据的维护工作。

要使用ContentProvider获取本地所有的音频文件，可以执行以下步骤：

1. 获取ContentResolver对象，这个对象是用于和ContentProvider通信的接口。

```java
ContentResolver resolver=context.getContentResolver();
```

2. 构建查询的URI和投影（projection）数组，这个URI指向音频文件的存储位置，投影数组用于指定我们需要查询的列。

```java
Uri uri=MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;
        String[]projection={
        MediaStore.Audio.Media._ID,
        MediaStore.Audio.Media.TITLE,
        MediaStore.Audio.Media.ARTIST,
        MediaStore.Audio.Media.DATA
        };
```

3. 使用ContentResolver的query方法查询音频文件数据，该方法返回一个Cursor游标对象，其中包含了查询结果。

```java
Cursor cursor=resolver.query(uri,projection,null,null,null);
```

4. 遍历Cursor对象，从中获取音频文件的信息，例如文件名、路径、时长等。

```java
while(cursor.moveToNext()){
        String title=cursor.getString(cursor.getColumnIndex(MediaStore.Audio.Media.TITLE));
        String artist=cursor.getString(cursor.getColumnIndex(MediaStore.Audio.Media.ARTIST));
        String path=cursor.getString(cursor.getColumnIndex(MediaStore.Audio.Media.DATA));
        long duration=cursor.getLong(cursor.getColumnIndex(MediaStore.Audio.Media.DURATION));
        // TODO: 处理获取到的音频文件信息
        }
```

5. 最后，在使用完Cursor对象后，需要调用它的close方法关闭游标。

```java
cursor.close();
```

综上所述，通过以上步骤，可以使用ContentProvider获取本地所有的音频文件，并从中提取所需信息。需要注意的是，由于查询可能会返回大量数据，因此最好将查询放在异步线程中执行，以免阻塞UI线程。

同时因为是从本地读取数据，所以需要添加权限:

```xml 
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
```

## 五、 ListView

### 1.ListView 如何提高其效率？

- 复用ConvertView，使用历史的view
- 自定义静态类ViewHolder，减少findViewById 的次数
- **异步加载数据**，**分页加载数据**
- 使用WeakReference 引用ImageView对象

### 2.当 ListView 数据集改变后，如何更新 ListView

使用该 ListView 的 adapter 的 `notifyDataSetChanged()`方法。该方法会使 ListView 重新绘制。

### 3.ListView 如何实现分页加载（★★★★★）

在 ListView 中添加滑动监听器。只关心静止状态：当滑动状态为 `SCROLL_STATE_IDLE`
（即空闲状态）且滑动到底部时，触发分页加载的操作，关心最后一个可见的条目，如果最后一个可见条目就是数据适配器（集合）里的最后一个，此时可加载更多的数据。在每次加载的时候，计算出滚动的数量，当滚动的数量大于等于总数量的时候，可以提示用户无更多数据了。

### 4.ListView 可以显示多种类型的条目吗（★★）

是的，ListView 可以显示多种类型的条目。这通常称为多布局类型列表或多类型列表。

实现多类型列表的关键在于让 ListView 的 Adapter 可以处理多个不同类型的数据，并根据数据类型的不同，显示对应的条目布局。

一种实现方式是通过重写 Adapter 中的 getViewTypeCount 和 getItemViewType 方法。其中，getViewTypeCount 方法用于返回 ListView
中不同类型的视图的总数，而 getItemViewType 方法则用于返回指定位置上的数据项所使用的视图类型。在 getView 方法中，根据 getItemViewType
返回的视图类型，选择对应的布局来显示数据。

另一种实现方式是通过 RecyclerView 来实现多类型列表，其中 RecyclerView 中的 Adapter 支持多类型条目的显示，并且性能比 ListView
更好。RecyclerView 的实现方式类似于 ListView，需要重写 getItemViewType 和 onCreateViewHolder 方法，并在 onCreateViewHolder
方法中返回对应的 ViewHolder。

### 5.ListView 如何定位到指定位置

1. ListView 定位到指定位置

（1）使用 `setSelection()` 方法

setSelection 方法可以让 ListView 滚动到指定位置，其中参数 position 表示要定位的位置。

例如，使用以下代码可以将 ListView 定位到第 10 个位置：

```java
listView.setSelection(9);
```

（2）使用 `smoothScrollToPosition()` 方法

smoothScrollToPosition 方法可以平滑地滚动到指定位置。

例如，使用以下代码可以让 ListView 平滑地滚动到第 10 个位置：

```java
listView.smoothScrollToPosition(9);
```

1. RecyclerView 定位到指定位置

RecyclerView 中定位到指定位置的方法与 ListView 有所不同。通常使用以下方法来实现：

（1）使用 `scrollToPosition()` 方法

scrollToPosition 方法可以将 RecyclerView 定位到指定位置，其中参数 position 表示要定位的位置。

例如，使用以下代码可以将 RecyclerView 定位到第 10 个位置：

```java
recyclerView.scrollToPosition(9);
```

（2）使用 `smoothScrollToPosition()` 方法

smoothScrollToPosition 方法可以平滑地滚动到指定位置。

例如，使用以下代码可以让 RecyclerView 平滑地滚动到第 10 个位置：

```java
recyclerView.smoothScrollToPosition(9);
```

需要注意的是，RecyclerView 中的布局管理器可能会影响 scrollToPosition 和 smoothScrollToPosition
方法的表现。例如，LinearLayoutManager 支持垂直和水平滚动，而 GridLayoutManager 则支持网格布局。因此，在使用 RecyclerView
定位到指定位置时，需要注意当前使用的布局管理器是否支持相应的滚动方式。

### 6.如何在ScrollView 中如何嵌入 ListView（★★★★）

- 通常情况下我们不会在 ScrollView 中嵌套 ListView，但是如果必须嵌套的话也是可以的。
- 在 ScrollView 添加一个 ListView 会导致 listview 控件显示不全，通常只会显示一条，这是因为两个控件的滚动事件冲突导致。需要通过 listview 中的item
  数量去计算 listview 的显示高度，从而使其完整展示。

### 7.ListView、RecyclerView 中如何优化图片（★★）

在 RecyclerView 中优化图片主要有以下几种方法：

1. 使用图片压缩

使用图片压缩可以减小图片的文件大小，从而减少内存的消耗。常用的图片压缩方法包括使用压缩库如 Luban、Tiny、Glide 等对图片进行压缩，或者使用 BitmapFactory.Options
对图片进行压缩处理。

2. 使用图片缓存

在加载图片时，使用图片缓存可以减少重复加载同一张图片的次数，从而提高图片加载速度，并减少内存的消耗。常用的图片缓存库包括 Glide、Picasso、Fresco 等。

3. 使用图片裁剪

使用图片裁剪可以将图片的大小裁剪为合适的尺寸，以适应显示的控件大小。可以使用 Glide、Picasso 等图片加载库中的裁剪方法，或者使用 BitmapFactory 对图片进行裁剪处理。

4. 延迟加载

可以使用 RecyclerView 中的 onScrollStateChanged 方法监听 RecyclerView 的滑动状态，并在滑动停止时才加载图片，从而减少内存的消耗。

5. 优化 ViewHolder

ViewHolder 是 RecyclerView 中用于缓存布局中各个视图的类。在 ViewHolder 中，可以使用 findViewById 方法对布局中的各个视图进行缓存，从而减少
findViewById 方法的调用次数，提高布局的加载速度。

综上所述，为了在 RecyclerView 中优化图片，需要使用图片压缩、图片缓存、图片裁剪、延迟加载等方法，并优化 ViewHolder 类的实现。

### 8.ListView 或 RecyclerView 中图片错位的问题是如何产生的（★★★）

ListView 或 RecyclerView 中图片错位的问题一般是由于以下原因造成的：

1. 布局复用问题

ListView 和 RecyclerView
的布局复用机制会导致视图的重复利用，即当一个视图滚动离开屏幕时，它会被回收，再次出现时会被重新利用，而不是重新创建。如果复用的视图中含有图片，并且在滚动时图片还未加载完成，就可能会导致图片错位的问题。

2. 图片加载问题

图片的加载可能会出现各种问题，如网络延迟、加载过程中被回收等，这些都可能导致图片显示错位的问题。另外，图片加载库的版本也可能影响图片错位的问题，因为不同版本的图片加载库实现方式可能不同。

3. 异步加载问题

如果使用异步加载图片，那么当图片加载完成时，可能已经滚动到了另一个位置，此时加载的图片可能会显示在错误的位置，导致图片错位。

4. 布局中图片的位置计算问题

如果布局中包含多个 ImageView，并且它们的位置是根据其他视图计算得出的，那么在滚动时，可能会导致位置计算出现错误，从而导致图片错位的问题。

为了解决图片错位的问题，可以采取以下措施：

1. 在布局中使用占位符

在布局中使用占位符，例如使用空白的 View 或者 ProgressBar 来占据图片的位置，等到图片加载完成后再将占位符替换成真正的图片。

2. 使用图片加载库

使用图片加载库可以有效地解决图片加载问题，例如 Glide、Picasso 等都提供了缓存机制和异步加载机制，可以有效地避免图片错位的问题。

3. 同步更新数据源

及时更新数据源可以保证 ListView 或 RecyclerView 中的数据与实际情况相符，避免出现图片错位等问题。

4. 使用布局中视图的唯一标识符

在使用 RecyclerView 时，可以使用视图的唯一标识符来避免视图错位的问题。通过 getItemId 方法返回视图的唯一标识符，可以确保 RecyclerView 中的视图与数据源相对应。

10. ### 如何刷新 ListView或RecyclerView 中单个 item 的数据， 不刷新整个ListView或RecyclerView 的数据？

修改单个 Item 的数据,然后调用适配器的 `notifyDataSetChanged()` 方法

### 六、Intent

1.   ### Intent 传递数据时，可以传递哪些类型数据？

 	1. 基本数据类型
 	2. 字符串
 	3. 数组
 	4. 实现了 Serializable 或 Parcelable 接口的对象
 	5. Bundle 对象

### 2.Serializable 和Parcelable 的区别（★★★）

1. 序列化方式不同：

Serializable 使用 Java 自带的序列化机制，在序列化和反序列化时需要进行大量的 I/O 操作，效率较低。而 Parcelable 使用 Android 提供的 Parcelable
机制，在序列化和反序列化时只需要进行内存操作，效率更高。

2. 传递数据的大小：

Serializable 在序列化过程中会产生大量的中间对象，这些对象会占用较大的内存空间，因此在传递较大的数据时，可能会导致内存不足的问题。而 Parcelable
机制可以通过重用对象池来避免这个问题。

3. 实现方式不同：

Serializable 只需要实现一个接口即可，而 Parcelable 则需要手动实现 writeToParcel() 和 createFromParcel() 两个方法。

4. 可读性不同：

Serializable 生成的序列化数据是基于 Java 类型的反射机制，可读性较强，而 Parcelable 生成的序列化数据比较难以阅读。

### 3.请描述一下 Intent 和 IntentFilter（★★★）

Intent 和 IntentFilter 是 Android 中非常重要的两个类，它们分别用于表示一个操作或者一组操作，以及用于过滤对应操作的条件。

具体来说，Intent 代表了一个应用程序执行的某个动作，可以包含一些额外的数据，比如要启动的 Activity、要执行的 Service、要广播的消息等等。通过
Intent，我们可以在应用程序之间进行通信，或者在应用程序内部进行组件之间的跳转。

而 IntentFilter 则是一组条件，用于描述哪些操作可以响应当前的 Intent。IntentFilter 包含了一些 **Action**、**Category** 和 **Data**
等信息，其中 **Action 表示当前 Intent 的动作**，Category 表示当前 Intent 的类型，**Data 则表示当前 Intent 操作所要操作的数据**。通过对
IntentFilter 进行匹配，系统可以找到合适的组件来响应当前的 Intent。

通常情况下，我们在启动 Activity、Service、广播等组件时，都需要通过 Intent 来指定具体的操作，并通过 IntentFilter
来确保当前的操作能够被正确地处理。例如，我们可以通过指定 Action 和 Category 来启动一个特定的 Activity，或者通过指定 Action 来发送一个广播消息，等等。

### 4.intent 的意义

实现组件之间通信和跳转的核心机制

## 七、Fragment

### 1.Fragment 跟Activity 之间是如何传值的

1. Bundle
   在 Activity 中创建一个 Bundle 对象，然后调用 Fragment setArguments() 方法来传递数据。在 Fragment 中，我们可以通过
   getArguments() 方法获取到这个 Bundle 对象，并从中获取我们需要的数据。
   在 Activity 中：

   ```java
   Bundle bundle = new Bundle(); 
   bundle.putString("key", "value"); 
   MyFragment fragment = new MyFragment(); fragment.setArguments(bundle);
   ```

   在 Fragment 中：
   ```java
   Bundle bundle = getArguments();
   if (bundle != null) {
       String value = bundle.getString("key");
   }
   ```


2. 接口回调
   通过在 Fragment 中定义一个接口，在 Activity 中实现该接口，并将 Activity 的实例作为参数传递给 Fragment，从而让 Fragment 可以调用 Activity
   中的方法来传递数据。这种方式适用于需要在 Fragment 中触发 Activity 中的一些操作或者传递复杂数据的情况。

3. 直接调用 Activity 方法：在 Fragment 中通过 `getActivity()`方法获取到 Activity 的实例，然后直接调用 Activity 的方法来传递数据。在
   Activity 中可以通过 `fragmentManager.findFragmentById(id)` 获取到 Fragment 实例，获取到 Fragment 之后就可以调用
   Fragment 的方法。。这种方式比较简单，但需要注意避免内存泄漏。

4. ViewModel：通过在 Fragment 和 Activity 中共享 ViewModel 对象，从而实现数据共享。这种方式适用于需要在 Fragment 和 Activity
   中共享数据的情况。

### 2.描述一下 Fragment 的生命周期

1. onAttach()：当 Fragment 被添加到 Activity 中时，该方法被调用，表示 Fragment 已经与 Activity 关联。
2. onCreate()：该方法被调用时，表示 Fragment 正在创建。在该方法中通常进行一些初始化操作，例如设置布局等。
3. onCreateView()：该方法被调用时，表示 Fragment 的布局已经创建完成，但还未添加到视图中。在该方法中通常创建和返回 Fragment 的视图。
4. onActivityCreated()：该方法被调用时，表示 Fragment 所依赖的 Activity 已经完成 onCreate() 方法的执行。在该方法中通常进行一些需要访问
   Activity 的操作。
5. onStart()：该方法被调用时，表示 Fragment 正在启动。在该方法中通常进行一些 UI 显示相关的操作。
6. onResume()：该方法被调用时，表示 Fragment 已经显示在屏幕上，并且用户正在与之交互。在该方法中通常进行一些用户交互相关的操作。
7. onPause()：该方法被调用时，表示 Fragment 正在暂停。在该方法中通常进行一些与用户交互相关的操作的暂停。
8. onStop()：该方法被调用时，表示 Fragment 已经停止。在该方法中通常进行一些 UI 显示相关的操作的停止。
9. onDestroyView()：该方法被调用时，表示 Fragment 的视图正在被销毁。在该方法中通常进行一些与视图相关的清理操作。
10. onDestroy()：该方法被调用时，表示 Fragment 正在被销毁。在该方法中通常进行一些与资源相关的清理操作。
11. onDetach()：该方法被调用时，表示 Fragment 已经与 Activity 分离。在该方法中通常进行一些与 Activity 解除关联的操作。

<img src="https://cdn.jsdelivr.net/gh/ChengYang1998/blogImage@main/PicGo/image-20230325135510255.png" alt="image-20230325135510255" style="zoom: 50%;" />

### 3.FragmentManager 的 replace 和 add 两种方法切换Fragment 时有什么不同

1. replace 方法：使用该方法会将当前的 Fragment 替换为指定的 Fragment，也就是说，当前的 Fragment 不再保留在后台栈中，完全被新的 Fragment 替代。使用
   replace 方法进行 Fragment 切换时，原来的 Fragment 的生命周期方法 onPause()、onStop()、onDestroyView()、onDestroy()
   、onDetach() 将被依次调用。同时，新的 Fragment 的生命周期方法 onAttach()、onCreate()、onCreateView()
   、onActivityCreated()、onStart()、onResume() 将依次被调用。

2. add 方法：使用该方法会将指定的 Fragment 添加到当前的 Fragment 上方，即将新的 Fragment 添加到当前的 Fragment 后面。使用 add 方法进行
   Fragment 切换时，当前的 Fragment 不会被销毁，而是保留在后台栈中，可以通过返回键重新回到该 Fragment。同时，新的 Fragment 的生命周期方法 onAttach()
   、onCreate()、onCreateView()、onActivityCreated()、onStart()、onResume() 将依次被调用，原来的 Fragment
   的生命周期方法不会被调用。

### 4.Fragment 如何实现类似Activity 栈的压栈和出栈效果的？

- 在 FragmentManager 中，维护了一个 Fragment 栈来保存所有的 Fragment，一个指针来指示当前栈顶的 Fragment。

- FragmentFragmentManager 内部实现了一个 BackStackRecord 类，它可以看作是一个包含多个操作的栈，其中操作包括添加、替换、移除 Fragment
  等等。每当一个新的操作被执行时，FragmentManager 会将其添加到 BackStackRecord 中，并将该 BackStackRecord 放入一个栈中，这个栈可以看作是
  Fragment 栈，保存了所有的 BackStackRecord。当用户按下 Back 键时，FragmentManager 会从 Fragment 栈中取出最后一个
  BackStackRecord，然后反向执行其中的操作，实现了 Fragment 的退栈操作。

- 因此，可以说 FragmentManager 的内部实现既不是简单的数组实现，也不是双向链表结构，而是一种基于栈的实现方式。

### 5.Fragment 在项目中的使用

1. 模块化：独立设计、测试和调试
2. 可重用性：减少了代码的重复。
3. Fragment 可以在运行时动态添加、移除、替换和组合。
4. 屏幕适配性
5. 状态保存：Fragment 可以帮助开发人员保存 Activity 中的状态信息，这使得当 Activity 被销毁后可以快速地恢复状态信息。

### 6.如何切换 fragment,不重新实例化

可以使用 FragmentTransaction 类的 replace() 方法来切换 Fragment，而不需要重新实例化：

1. 获取 FragmentManager 对象，通常可以通过调用`getActivity().getSupportFragmentManager()`
   或 `getChildFragmentManager()` 方法来获取。
2. 创建一个 FragmentTransaction 对象，可以通过调用 FragmentManager 的 `beginTransaction()` 方法来创建。
3. 使用 FragmentTransaction 的 `replace()` 方法来替换当前的 Fragment，该方法接受三个参数：**容器视图 ID**、**要添加的 Fragment**
   和**标记（可选）**。
4. 调用 FragmentTransaction 的 `commit()` 方法来提交事务。

例如，假设我们有两个 Fragment，分别为 FragmentA 和 FragmentB，如果要从 FragmentA 切换到 FragmentB，可以使用以下代码：

```java
FragmentB fragmentB=new FragmentB();
        FragmentManager fragmentManager=getActivity().getSupportFragmentManager();
        FragmentTransaction transaction=fragmentManager.beginTransaction();
        transaction.replace(R.id.container,fragmentB,"FragmentBTag");
        transaction.addToBackStack(null);
        transaction.commit();
```

其中，R.id.container 是要用来显示 Fragment 的容器视图 ID，`"FragmentBTag"` 是用来标记 Fragment
的字符串，`addToBackStack(null)` 方法将当前的 Fragment 添加到返回堆栈中，以便在用户按下返回按钮时可以返回到 FragmentA。注意，在切换 Fragment
时，需要使用要切换到的 Fragment 的实例来替换当前的 Fragment。

# 第二章：Android 高级

## 一、Android 性能优化

### 1、如何对 Android 应用进行性能分析（★★★★）

TraceView、Android Profiler、Systrace、Memory Profiler、Network Profiler等常规工具，还有以下几个新的工具：Jetpack
Benchmark、Android Vitals、LeakCanary

### 2、什么情况下会导致内存泄露（★★）

1. 静态引用：static 是 Java 中的一个关键字，当用它来修饰成员变量时，那么该变量就属于该类，而不是该类的实例。所以用 static
   修饰的变量，它的生命周期是很长的，如果用它来引用一些资源耗费过多的实例（Context 的情况最多），这时就要谨慎对待了。
   如果您在代码中使用静态引用，它将会持有一个对象的引用，这个对象可能已经不再需要，但是由于静态引用，它将无法被垃圾回收器释放，导致内存泄漏。

   ```java
   public class ClassName {
       private static Context mContext;
       //省略
   }
   ```

   以上的代码是很危险的，如果将 Activity 赋值到 mContext 的话。那么即使该 Activity 已经 onDestroy，但是由于仍有对象保存它的引用，因此该 Activity
   依然不会被释放。

2. 长时间的后台任务：如果您的应用程序在后台运行，并且持续进行某个操作，但是没有及时释放资源，这将会导致内存泄漏。例如，如果您使用了 Handler 或者
   Timer，但是没有及时取消它们，它们将会持有 Activity 的引用，这将会阻止垃圾回收器回收 Activity。

3. 匿名内部类：如果您在 Activity 或者 Fragment 中使用匿名内部类，并且这个内部类持有 Activity 或者 Fragment
   的引用，这将会导致内存泄漏。因为匿名内部类在编译时会生成一个新的类，而这个类会持有外部类的引用，如果您没有及时取消对匿名内部类的引用，这将会导致内存泄漏。

4. Bitmap 对象：如果您在应用程序中使用 Bitmap 对象，并且没有及时释放它们，这将会导致内存泄漏。因为 Bitmap 对象通常非常大，如果没有及时回收，它们将会占用大量内存。

5. 生命周期不当：如果您的应用程序中的某个对象生命周期不当，例如它在 Activity 或者 Fragment 销毁后仍然存在，这将会导致内存泄漏。

6. 线程导致内存溢出

   当创建线程时，线程会持有一个对其所属的线程组的引用，而线程组又会持有一个对所有线程的引用。如果您在 Activity 或者 Fragment
   中创建了一个线程，但是没有及时取消对线程的引用，那么该线程将会一直存在，直到应用程序退出或者被强制终止。

   此外，当在应用程序中使用线程池时，线程池中的线程也可能导致内存泄漏。如果您使用的线程池是静态的，并且您没有及时清除已完成的任务，那么这些线程将会一直存在，直到应用程序退出或者被强制终止。

   ```java
   public class MyActivity extends Activity {
   
       @Override
       public void onCreate(Bundle savedInstanceState) { 
           super.onCreate(savedInstanceState); 
           setContentView(R.layout.main);
           new MyThread().start();
       }
       
       private class MyThread extends Thread{
           @Override
           public void run() {
               super.run();
               //do somthing while(true)
           }
       }
   }
   ```

   假设 MyThread 的 run 函数是一个很费时的操作，当我们开启该线程后，将设备的横屏变为了竖屏，一般情况下当屏幕转换时会重新创建 Activity，按照我们的想法，老的 Activity
   应该会被销毁才对，然而事实上并非如此。

   由于我们的线程是 Activity 的内部类，所以 MyThread 中保存了 Activity 的一个引用，当 MyThread 的 run 函数没有结束时，MyThread
   是不会被销毁的，因此它所引用的老的 Activity 也不会被销毁，因此就出现了内存泄露的问题。

   为了避免内存泄漏问题，可以使用**弱引用**来保存 Context 对象的引用，这样当 Context 不再被使用时，垃圾收集器可以自动回收它。

   以下是一个在线程内部使用弱引用保存 Context 引用的示例：

   ```java
   public class MyRunnable implements Runnable {
       private WeakReference<Context> mContextRef;
   
       public MyRunnable(Context context) {
           mContextRef = new WeakReference<>(context);
       }
   
       @Override
       public void run() {
           Context context = mContextRef.get();
           //检查其是否已经被回收
           if (context != null) {
               // 在线程中使用 Context 对象
               Toast.makeText(context, "Hello World!", Toast.LENGTH_SHORT).show();
           }
       }
   }
   ```

   在上面的示例中，定义了一个名为 `MyRunnable` 的线程类，该类的构造函数接受一个 Context 对象，并使用弱引用来保存该对象的引用。在 `run()` 方法中，首先获取弱引用的
   Context 对象，如果该对象不为空，则可以在线程中使用它。如果 Context 对象已经被回收，则不会进行任何操作。

### 3、如何避免 OOM 异常（★★★★）

1. 优化图片资源的加载和显示。图片资源占用内存较大，特别是加载大图片时容易导致 OOM 异常。可以通过使用合适的图片压缩技术、延迟加载、缓存等方式来优化图片资源的加载和显示。
2. 避免内存泄漏。在 Android 中，内存泄漏是引发 OOM 异常的主要原因之一。可以通过避免静态变量持有 Activity 的引用、正确地使用 Context 等方式来避免内存泄漏。
3. 释放不再使用的资源。及时释放不再使用的资源，包括 Bitmap、File、数据库连接、流等，可以有效地避免 OOM 异常。
4. 使用更高效的数据结构。有些数据结构，如 ArrayList、HashMap，在数据量较大时容易引起 OOM 异常。可以使用更高效的数据结构，如
   SparseArray、ArrayMap、LruCache 等，来优化内存使用。
5. 控制并发线程数量。过多的并发线程也容易引发 OOM 异常。可以通过线程池来控制并发线程的数量，以减轻内存压力。
6. 使用分页加载技术。对于大数据量的列表，可以使用分页加载技术，避免一次性加载所有数据导致 OOM 异常。

总的来说，避免 OOM 异常需要从多个方面进行优化，包括资源的加载和释放、数据结构的选择、并发线程数量的控制等，需要综合考虑应用程序的实际情况进行优化。

### 4、Android 中如何捕获未捕获的异常（★★★）

1.   在应用程序的主线程中设置默认的未捕获异常处理器。这可以通过 `Thread.setDefaultUncaughtExceptionHandler()`
     方法来实现。可以在自定义的异常处理器中对异常进行记录、上传、打印等操作。例如：

     1. 自定义一个 Application，比如叫 MyApplication 继承 Application 实现 UncaughtExceptionHandler。
     2. 覆写UncaughtExceptionHandler 的onCreate 和uncaughtException 方法。

         ```java
         @Override
         public void onCreate(){
                 super.onCreate();
                 Thread.setDefaultUncaughtExceptionHandler(this);
                 }
         
         
         @Override
         public void uncaughtException(final Thread thread,final Throwable ex){
         
                 new Thread(new Runnable(){
                     @Override
                     public void run(){
                         Looper.prepare();
                         System.out.println(Thread.currentThread());               
          		Toast.makeText(getApplicationContext(),"thread="+thread.getId(ex=+ex.toString(),1).show();Looper.loop();    
                                }
                          }).start();
         				SystemClock.sleep(3000);    
         				android.os.Process.killProcess(android.os.Process.myPid());
         
                 }
         
         }
         ```

         >   在 onCreate 方法中我们给 Thread 类设置默认异常处理 handler，这很重要。

         在 uncaughtException 方法中我们必须新开辟个线程进行我们异常的收集工作，然后将系统给杀死。

2.   在每个线程中使用 `try-catch` 块来捕获异常。如果异常没有被捕获，将会抛出 `UncaughtExceptionHandler`，如果设置了默认的未捕获异常处理器，那么它就会被调用。

### 5、ANR 是什么？怎样避免和解决 ANR（★★★★★）

ANR（Application Not Responding）是指应用程序在执行某个操作时出现无响应情况的错误。在 Android 中，如果应用程序在主线程上进行长时间的操作（例如，网络请求、文件读写等），就有可能引发 ANR 错误。

Android 中的 ANR 错误一般有三种类型：

1.  KeyDispatchTimeout ANR：当应用程序在 5 秒钟内无法响应关键事件（例如按键事件、触摸事件等）时，会触发 KeyDispatchTimeout ANR 错误。
2.  ServiceTimeout ANR：当应用程序的 Service 组件在规定的时间内（20 秒）未响应或未完成其操作时，将会触发 ServiceTimeout ANR 错误。
3.  BroadcastTimeout ANR：当应用程序中的 BroadcastReceiver 在 10 秒钟内无法处理 Broadcast 消息时，会触发 BroadcastTimeout ANR 错误。

为了避免和解决 ANR，可以采取以下措施：

1.  尽量不要在主线程上执行长时间的操作。可以使用 AsyncTask、HandlerThread 或者 IntentService 等方式来将耗时的操作放在子线程中执行。
2.  避免在主线程中进行耗时的 I/O 操作，例如读写文件、网络请求等。可以使用异步 I/O 或者非阻塞 I/O 的方式来处理这些操作。
3.  减少主线程中的任务量，可以通过优化算法、减少不必要的计算等方式来降低主线程的负载。
4.  避免在主线程中进行 UI 操作，例如更新 UI、绘制界面等。可以使用 Handler、View.post() 等方式来将 UI 操作放在主线程的消息队列中执行。

要查找 ANR 错误，您可以使用以下方法：

1.  查看系统日志：ANR 错误会在系统日志中被记录下来。使用 Android Studio 的 Logcat 或命令行 adb 工具可以获取系统日志。
2.  分析 trace 文件：Android 系统会在 ANR 发生时生成 trace 文件，该文件包含了应用程序的调用栈信息。使用 Android Studio 的 Profiler 或其他性能分析工具可以分析 trace 文件。导出/data/data/anr/traces.txt，找出函数和调用过程。
3.  使用 ANR 监测工具：可以使用 ANR 监测工具来检测应用程序是否发生 ANR 错误，并且可以自动生成 ANR 报告。
4.  使用第三方服务：一些第三方服务可以帮助您监测应用程序中的 ANR 错误，并且会及时通知您。例如，Firebase Crashlytics、Sentry 等。

### 6、Android 线程间通信有哪几种方式（★★★）

在 Android 中，线程间通信的方式主要有以下几种：

1.  Handler：通过 Handler 可以将消息从一个线程发送到另一个线程。它可以用于异步任务、延时执行任务等。使用 Handler，需要重写 handleMessage 方法，来处理接收到的消息。
2.  AsyncTask：AsyncTask 是 Android 提供的一个异步任务类，它可以方便地在后台执行任务并将结果传递到 UI 线程。AsyncTask 封装了 Handler 和线程池等机制，可以简化开发者的代码实现。
3.  BroadcastReceiver：BroadcastReceiver 用于接收系统或应用发送的广播消息。它可以用于跨进程或跨应用程序通信。
4.  Messenger：Messenger 是一种轻量级的 IPC 机制，它使用 AIDL 进行跨进程通信。
5.  ContentProvider：ContentProvider 是 Android 提供的一个跨进程数据共享的机制，可以实现进程间数据的共享和访问。
6.  Binder：Binder 是 Android 中用于实现进程间通信 (IPC) 的机制，它提供了一种高效的跨进程通信方式，可以支持一对多或多对一的进程通信方式。

### 7、Devik 进程，linux 进程，线程的区别（★）

在Android中，Devik进程、Linux进程和线程都是指计算机系统中的执行单元，它们之间的区别如下：

1.  Devik进程是Android中的一种特殊进程，它是由Zygote进程fork而来，主要用于运行应用程序。Devik进程之间相互独立，每个进程都有自己的虚拟机、堆栈和资源管理器。不同的应用程序通常运行在不同的Devik进程中，可以有效地保护系统的安全性和稳定性。
2.  Linux进程是指在Linux系统中运行的进程，它们同样也可以在Android系统中运行。Linux进程可以看做是系统资源的分配单位，它们之间可以通过进程间通信机制进行数据交换和协作。在Android中，Devik进程其实就是运行在Linux进程中的一个用户空间进程。
3.  线程是进程中的执行单元，是计算机系统中最小的可调度执行单元。线程共享进程的内存空间和其他资源，不同的线程之间可以通过共享内存等机制进行通信。在Android中，Devik进程通常会包含多个线程，用于处理用户交互、网络通信、数据处理等任务。

综上所述，Devik进程、Linux进程和线程都是计算机系统中的执行单元，它们之间的区别主要在于它们的作用和使用场景。Devik进程主要用于运行Android应用程序，Linux进程用于管理系统资源和提供服务，而线程则是执行任务的最小单元。

### 8、描述一下android 的系统架构？

Android是一个基于Linux内核的开源操作系统，它的系统架构可以分为四层：

1.  应用层（Application Layer）：这一层是Android系统最上层，包括了所有的应用程序，如通讯录、浏览器、短信、相机、游戏等等。应用层向下调用了下面的三个层次的API，来实现应用程序的功能。
2.  应用框架层（Application Framework Layer）：这一层提供了一系列的API，供应用程序调用，包括了视图系统、资源管理器、通知管理器、活动管理器、内容提供者等等。应用程序可以通过这些API来实现各种功能，如窗口管理、事件处理、多媒体播放、网络通信等等。
3.  系统运行时库层（System Runtime Layer）：这一层主要提供了核心的系统运行时库，包括了ART虚拟机、核心库、Dalvik虚拟机、Webkit等等。这些库提供了Android系统的基础设施，如Java虚拟机、数据库管理、文件系统、网络协议等等。
4.  Linux内核层（Linux Kernel Layer）：这一层是Android系统的最底层，包括了Linux内核、硬件驱动、内存管理、进程管理、安全管理等等。Linux内核提供了操作系统的核心功能，如进程管理、内存管理、文件系统等等，同时也为Android系统的高层提供了底层支持，如驱动程序和硬件接口等。

<img src="https://cdn.jsdelivr.net/gh/ChengYang1998/blogImage@main/PicGo/Clip_20230326_212225.png" alt="Clip_20230326_212225" style="zoom:50%;" />



### 9、android 应用对内存是如何限制的?我们应该如何合理使用内存？

-   Android 每一个应用的堆内存大小有限，通常的情况为 16MB~512MB
    -   可通过 ActivityManager 的 getMemoryClass()来查询可用堆内存限制
    -   如果试图申请的内存大于当前余下的堆内存就会引发OutOfMemoryError

-   如何合理使用内存？
    -   采用分页加载
    -   缓存
    -   优化代码逻辑
    -   减少动画
    -   大图片压缩处理
    -   少使用静态变量
    -   使用弱引用

### 10、简述 android 应用程序结构是哪些？（★★★★）

<img src="https://cdn.jsdelivr.net/gh/ChengYang1998/blogImage@main/PicGo/image-20230326213735035.png" alt="image-20230326213735035" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ChengYang1998/blogImage@main/PicGo/image-20230326213748981.png" alt="image-20230326213748981" style="zoom:80%;" />

Android应用程序工程结构主要包括以下几个部分：

1.  AndroidManifest.xml文件：这个文件是Android应用程序的配置文件，它包含了应用程序的名称、版本号、权限、组件等信息。在开发过程中，开发者可以通过修改这个文件来配置应用程序的基本属性和特性。
2.  src目录：这个目录包含了应用程序的所有源代码文件，包括Java源代码、资源文件等。在开发过程中，开发者可以通过修改这些源代码文件来实现应用程序的各种功能和特性。
3.  res目录：这个目录包含了应用程序的所有资源文件，如布局文件、图标、字符串、样式、颜色等等。在开发过程中，开发者可以通过修改这些资源文件来实现应用程序的各种UI效果和交互特性。
4.  lib目录：这个目录包含了应用程序所需的所有库文件，如第三方库、系统库等等。在开发过程中，开发者可以通过将这些库文件添加到应用程序的lib目录中，来实现各种功能和特性。
5.  assets目录：这个目录包含了应用程序的所有非编译资源文件，如音频、视频、HTML、JavaScript等等。在开发过程中，开发者可以通过修改这些资源文件来实现应用程序的各种功能和特性。
6.  build.gradle文件：这个文件是Android应用程序的构建文件，它包含了应用程序的编译和打包的相关配置信息。在开发过程中，开发者可以通过修改这个文件来实现应用程序的自动构建和打包。

### 11、请解释下 Android 程序运行时权限与文件系统权限的区别？（★★★）

Android程序运行时权限和文件系统权限是两个不同的概念。

1.  运行时权限：Android程序运行时权限指的是应用程序在运行时需要访问系统资源（如相机、定位、通讯录等）时，需要向用户请求授权。如果用户授权，则应用程序可以访问相关的系统资源；如果用户不授权，则应用程序无法访问相关的系统资源。在Android 6.0及以上版本中，运行时权限是必需的，否则应用程序会崩溃。
2.  linux文件系统权限：Android程序文件系统权限指的是应用程序需要访问存储设备（如SD卡）上的文件时，需要获取相应的文件系统权限。不同的文件系统权限对应不同的访问级别，例如只读、只写、读写等。如果应用程序没有相应的文件系统权限，则无法访问存储设备上的文件，从而导致应用程序无法正常工作。

### 12、Framework 工作方式及原理，Activity 是如何生成一个 view 的，机制是什么？（★★）

Android Framework（框架）是Android系统中的一种核心组件，它提供了应用程序开发所需的各种API和工具，其中Activity是一种重要的UI组件，Activity可以通过setContentView()方法来生成一个View，并在用户界面上显示出来。具体来说，Activity生成一个View的机制如下：

-   Activity创建一个View时，Android系统会依次调用该View的`onMeasure()`、`onLayout()`和`onDraw()`方法来实现该View的显示。其中，**onMeasure()方法用于测量该View的大小**，**onLayout()方法用于确定该View在屏幕上的位置和大小**，**onDraw()方法用于绘制该View的内容**。因此，在绘制该View之前，Android系统会先调用onMeasure()方法来计算该View应该显示的大小。

-   在调用onMeasure()方法时，Android系统会传入两个参数：widthMeasureSpec和heightMeasureSpec。这两个参数分别用于指定该View的宽度和高度，它们是由父容器通过LayoutParams传递给该View的,如果该View的宽度和高度不能满足父容器的要求，就需要在onMeasure()方法中对该View进行重新测量，以确保该View的宽度和高度符合父容器的要求。

-   总之，在Android中，Activity创建一个View时，系统会:
    1.   先调用onMeasure()方法来计算该View的大小
    2.   然后调用onLayout()方法来确定该View在屏幕上的位置和大小
    3.   最后调用onDraw()方法来绘制该View的内容

特殊情况：

SurfaceView是一种特殊的View组件，它提供了一种基于双缓冲区的绘图机制，可以实现更高效、更流畅的UI绘制。与普通的View组件不同，SurfaceView在绘制时不会阻塞UI线程，而是在后台线程中完成绘制操作，从而提高了UI的响应性能和绘制效率。

一般的使用场景和使用原因如下：

1.  动画和游戏：SurfaceView适合用于动画和游戏等需要高效、流畅绘制的场景，因为它可以在**后台线程中绘制，避免了UI线程阻塞**。
2.  视频播放：SurfaceView适合用于视频播放，因为它可以将视频图像作为绘图表面，通过OpenGL ES等技术来实现**硬件加速**，从而提高播放效率和流畅度。
3.  直播和摄像头：SurfaceView适合用于实时直播和摄像头预览等场景，因为它可以**快速**地将摄像头采集的图像数据显示在屏幕上，同时支持图像旋转、缩放等功能。

### 13、多线程间通信和多进程之间通信有什么不同，分别怎么实现？（★★★★★）

在Android中，多线程间通信和多进程间通信有着不同的实现方式和目的。

-   多线程间通信是指在同一个进程中不同的线程之间进行通信，目的是为了实现数据共享和协同工作等功能。可以使用以下方式进行多线程间通信：

    1.  使用synchronized关键字来实现同步锁，确保多个线程之间对共享资源的访问是同步的。
    2.  使用wait()和notify()方法，实现线程的等待和唤醒，以避免多个线程之间的争用。
    3.  使用Handler、AsyncTask、Looper和Message等类，实现线程之间的消息传递，完成任务的分发和执行等功能。

    -   使用Handler和Message实现线程之间的消息传递：

        ```java
        class MyThread extends Thread {
            private Handler mHandler;
        
            public MyThread(Handler handler) {
                mHandler = handler;
            }
        
            @Override
            public void run() {
                // 子线程中向主线程发送消息
                Message msg = mHandler.obtainMessage();
                msg.what = 1;
                msg.obj = "Hello from child thread!";
                mHandler.sendMessage(msg);
            }
        }
        
        class MainActivity extends AppCompatActivity {
            private TextView mTextView;
        
            private Handler mHandler = new Handler() {
                @Override
                public void handleMessage(Message msg) {
                    if (msg.what == 1) {
                        String text = (String) msg.obj;
                        mTextView.setText(text);
                    }
                }
            };
        
            @Override
            protected void onCreate(Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                setContentView(R.layout.activity_main);
        
                mTextView = findViewById(R.id.text_view);
        
                // 创建并启动子线程
                MyThread thread = new MyThread(mHandler);
                thread.start();
            }
        }
        ```

        上述代码中，子线程MyThread向主线程发送消息，主线程中的Handler接收到消息后更新UI。在MyThread中，我们首先使用`mHandler.obtainMessage()`方法获取一个Message对象，然后设置消息的what和obj属性，最后使用`mHandler.sendMessage()`方法将消息发送到主线程。

        在主线程中，我们创建了一个Handler对象，并覆盖了`handleMessage()`方法，该方法用于接收并处理来自子线程的消息。当接收到消息时，我们首先检查消息的what属性是否为1，然后从消息的obj属性中获取字符串内容，并将其设置为TextView的文本。

    -   使用Looper和Handler实现线程之间的消息传递：

        ```java
        class MyThread extends Thread {
            private Handler mHandler;
        
            public MyThread(Handler handler) {
                mHandler = handler;
            }
        
            @Override
            public void run() {
                // 在子线程中创建一个Looper对象
                Looper.prepare();
        
                // 创建一个Handler对象，并将其与Looper关联
                Handler childHandler = new Handler() {
                    @Override
                    public void handleMessage(Message msg) {
                        if (msg.what == 1) {
                            String text = (String) msg.obj;
                            Log.d("MyThread", "Received message: " + text);
                        }
                    }
                };
                Looper.loop();
        
                // 子线程中向自己发送消息
                Message msg = childHandler.obtainMessage();
                msg.what = 1;
                msg.obj = "Hello from child thread!";
                childHandler.sendMessage(msg);
        
                mHandler.sendEmptyMessage(2);
            }
        }
        
        class MainActivity extends AppCompatActivity {
            private Handler mHandler = new Handler() {
                @Override
                public void handleMessage(Message msg) {
                    if (msg.what == 2) {
                        Log.d("MainActivity", "Received message: Hello from child thread!");
                    }
                }
            };
        
            @Override
            protected void onCreate(Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                setContentView(R.layout.activity_main);
        
                // 创建并启动子线程
                MyThread thread = new MyThread(mHandler);
                thread.start();
            }
        }
        ```

        在MyThread中，我们首先使用Looper.prepare()方法创建一个Looper对象，并通过调用Looper.loop()方法进入消息循环，这样就可以处理来自其他线程的消息。然后，我们创建了一个Handler对象，并覆盖了handleMessage()方法，该方法用于接收并处理来自其他线程的消息。在最后，我们向子线程中的Handler对象发送了一条消息，并向主线程中的Handler对象发送了一条空消息。

        在主线程中，我们创建了一个Handler对象，并覆盖了handleMessage()方法，该方法用于接收并处理来自子线程的消息。当接收到消息时，我们首先检查消息的what属性是否为2，然后输出一条日志，表示已经成功接收到来自子线程的消息。

    - 使用AsyncTask实现线程之间消息传递的简单例子：

      ```java
      class MyTask extends AsyncTask<Void, Void, String> {
          private Handler mHandler;
      
          public MyTask(Handler handler) {
              mHandler = handler;
          }
      
          @Override
          protected String doInBackground(Void... voids) {
              // 在子线程中执行耗时操作
              return "Hello from child thread!";
          }
      
          @Override
          protected void onPostExecute(String s) {
              // 在主线程中更新UI
              Message msg = mHandler.obtainMessage();
              msg.what = 1;
              msg.obj = s;
              mHandler.sendMessage(msg);
          }
      }
      
      class MainActivity extends AppCompatActivity {
          private TextView mTextView;
      
          private Handler mHandler = new Handler() {
              @Override
              public void handleMessage(Message msg) {
                  if (msg.what == 1) {
                      String text = (String) msg.obj;
                      mTextView.setText(text);
                  }
              }
          };
      
          @Override
          protected void onCreate(Bundle savedInstanceState) {
              super.onCreate(savedInstanceState);
              setContentView(R.layout.activity_main);
      
              mTextView = findViewById(R.id.text_view);
      
              // 创建并执行异步任务
              MyTask task = new MyTask(mHandler);
              task.execute();
          }
      }
      ```

        在上述代码中，我们创建了一个MyTask类，继承自AsyncTask类。在doInBackground()方法中，我们在子线程中执行了一些耗时操作，并返回了一个字符串结果。在onPostExecute()方法中，我们将该结果通过Handler和Message等类传递到了主线程中，并更新了UI。

        在MainActivity中，我们创建了一个Handler对象，并覆盖了handleMessage()方法，该方法用于接收并处理来自子线程的消息。当接收到消息时，我们从消息的obj属性中获取字符串内容，并将其设置为TextView的文本。

        需要注意的是，在使用AsyncTask实现线程之间消息传递时，需要确保操作的线程安全性和消息的正确性，以避免出现数据竞争和错误。

-   多进程间通信是指在不同的进程之间进行通信，目的是为了实现数据共享和进程间协作等功能。在Android中，可以使用以下方式进行多进程间通信：

    1.  使用Intent和Bundle等类，通过在不同进程之间传递数据来实现进程间通信。
    2.  使用AIDL（Android Interface Definition Language）技术，定义跨进程通信的接口，实现进程间方法调用和参数传递等功能。
    3.  使用ContentProvider提供数据访问接口，其他进程可以通过ContentResolver访问ContentProvider提供的数据。

    需要注意的是，在多进程间通信中，由于涉及到进程间的数据共享，因此需要注意线程安全和进程间同步的问题，以保证通信的正确性和可靠性。



## 二、 Android 屏幕适配

1.   屏幕适配方式

     1.   适配方式 - dp

          名词解释： 

          -   分辨率：eg：480*800,1280*720。表示物理屏幕区域内像素点的总和。

              (切记：跟屏幕适配**没有任何关系**)因为我们既可以把 1280\*720 的分辨率做到 4.0 的手机上面。我也可以把1280\*720 的分辨率做到 5.0 英寸的手机上面，如果分辨率相同，手机屏幕越小清晰。

          -   px(pix)：像素，就是屏幕中最小的一个显示单元

          -   dpi（像素密度）：即每英寸屏幕所拥有的像素数，像素密度越大，显示画面细节就越丰富。

              |   ldpi   |  ~120dpi|
              | ---- | ---- |
              | mdpi | ~160dpi |
              | hdpi | ~240dpi |
              | xhdpi | ~320dpi |
              
              ![image-20230326233036873](https://cdn.jsdelivr.net/gh/ChengYang1998/blogImage@main/PicGo/image-20230326233036873.png)
              
              Android 应用在查找图片资源时会根据其分辨率自动从不同的文件目录下查找（这本身就是 Android 系统的适配策略），如果在低分辨的文件目录中比如 drawable-mdpi 中没有图片资源，其他目录中都有，当我们将该应用部署到
              mdpi 分辨率的手机上时，那么该应用会查找分辨率较高目录下的资源文件，如果较高分辨率目录下也没有资源则只好找较低目录中的资源了。

          -   常见手机屏幕像素及对应分别率级别：
              
              | ldpi   | 320\*240   |
              | ------ | ---------- |
              | mdpi   | 480*320    |
              | hdpi   | 800\*480   |
              | xxhdpi | 1920\*1080 |

     2.   适配方式 - dimens

          一般可以由屏幕适配框架完成

          跟 drawable 目录类似的，在 Android 工程的 res 目录下有 values 目录，这个是 默 认 的 目 录 ， 同 时 为 了 适 配 不 同 尺 寸 手 机 我 们 可 以 创 建 一 个values-1280x720 的文件夹，同时将 dimens.xml 文件拷贝到该目录下。

     3.   适配方式 - layout

          跟 values 一样，在 Android 工程目录中 layout 目录也支持类似 values 目录一样的适配，在 layout 中我们可以针对不同手机的分辨率制定不同的布局

          ![image-20230326233802413](https://cdn.jsdelivr.net/gh/ChengYang1998/blogImage@main/PicGo/image-20230326233802413.png)

     4.   适配方式之  - java 代码适配

          ```java
          public class MainActivity extends Activity {
              private static final String tag = null; // 定义一个标签变量，用于日志输出
          
              @Override
              protected void onCreate(Bundle savedInstanceState) {
                  super.onCreate(savedInstanceState);
                  // 去掉标题栏
                  requestWindowFeature(Window.FEATURE_NO_TITLE); 
                  setContentView(R.layout.activity_main);
          
                  // 获取 TextView 控件
                  TextView tv = (TextView) findViewById(R.id.tv);
          
                  // 获取屏幕的高度和宽度
                  DisplayMetrics metrics = new DisplayMetrics();
                  getWindowManager().getDefaultDisplay().getMetrics(metrics);
                  Constant.srceenHeight = metrics.heightPixels; // 屏幕的高度（像素）
                  Constant.srceenWidth = metrics.widthPixels; // 屏幕的宽度（像素）
          
                  // 日志输出屏幕的高度和宽度
                  Log.i(tag, "Constant.screenHeight = "+Constant.srceenHeight); 
                  Log.i(tag, "Constant.screenWidth = "+Constant.srceenWidth);
          
                  // 宽高各50%的布局参数
                  RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(
                          (int)(Constant.srceenWidth*0.5+0.5), (int)(Constant.srceenHeight*0.5+0.5));
          
                  // 给 tv 控件设置布局参数
                  tv.setLayoutParams(layoutParams);
              }
          }
          ```

     5.   适配方式 - weight 权重适配

          在控件中使用属性 android:layout_weight="1"可以起到适配效果，但是该属性的使用有如下规则：

          -   只能用在线性控件中，比如 LinearLayout。
          -   竖直方向上使用权重的控件高度必须为 0dp（Google 官方的推荐用法） 
          -   水平方向上使用权重的控件宽度必须为 0dp（Google 官方的推荐用法）

     6.   适配方式 - 百分比适配

2.   屏幕适配的处理技巧都有哪些（★★★★）

     -   使用dp、使用sp、使用限制性的尺寸和位置属性、使用不同分辨率的图片资源、使用布局文件的限制条件、使用适配器模式、使用系统提供的屏幕适配机制或框架

     -   横屏和竖屏的切换：

         -   不切换：

             在 配 置 Activity 的 地 方 进 行 如 下 的 配 置

             ```xml
             android:screenOrientation="portrait"
             ```

             这样就可以保证是竖屏总是竖屏了。

         -   切换横屏和竖屏适配：

             1.  在AndroidManifest.xml文件中的对应Activity的配置中添加"android:configChanges"属性：

             ```xml
             <activity android:name=".MainActivity"
                       android:configChanges="keyboardHidden|orientation">
                 ...
             </activity>
             ```

             2.  在对应的Activity中重写onConfigurationChanged()方法：

             ```java
             public class MainActivity extends AppCompatActivity {
                 ...
                 @Override
                 public void onConfigurationChanged(Configuration newConfig) {
                     super.onConfigurationChanged(newConfig);
                     if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) {
                         // 横屏时执行的操作
                         ...
                     } else if (newConfig.orientation == Configuration.ORIENTATION_PORTRAIT) {
                         // 竖屏时执行的操作
                         ...
                     }
                 }
             }
             ```

             在上述代码中，我们首先调用了父类的onConfigurationChanged()方法，以确保Activity能够正常响应配置变化。然后，我们判断当前屏幕的方向，如果是横屏，就执行横屏时的操作，如果是竖屏，就执行竖屏时的操作。在具体实现中，我们可以根据不同的需求，执行不同的操作，例如切换布局、调整控件大小、重新加载数据等。

             需要注意的是，当我们重写了onConfigurationChanged()方法后，系统将不会重新创建Activity，而是会调用此方法，因此我们需要确保在此方法中执行必要的操作，以**确保Activity在屏幕方向变化时能够正确显示和适应**。
         
     -   分辨率大小不同
     
         官方给的解决办法是创建不同的 layout 文件夹，这就需要对每种分辨率的手机都要写一个布局文件，造成很大的麻烦。可以通过使用 layout_weight 或第三方适配框架解决
     
3.   dp 和px 之间的关系（★★）

     dp：是 dip 的简写，指密度无关的像素。

     pixels=dips*(density/160)

     布局时最好使用 dp 来定义我们程序的界面



## 三、AIDL

### 1、什么是 AIDL 以及如何使用（★★★★）

-   Android 接口定义语言。
-   使用 aidl 可以帮助我们发布以及调用远程服务，实现跨进程通信。
-   将服务的 aidl 放到对应的 src 目录，工程的 gen 目录会生成相应的接口
    类
-   我们可以通过bindService()方法来绑定远程服务。在这个方法中，我们需要传入一个ServiceConnect接口，并覆写它的onServiceConnected()方法。这个方法的第二个参数IBinder对象其实就是已经在aidl中定义的接口，我们可以将这个IBinder对象强制转换为aidl中的接口类。通过这个IBinder对象获取到的对象其实是系统产生的代理对象，它可以在我们的进程和远程进程之间通信，起到了一个中间角色的作用。

### 2、AIDL 如何工作?能处理哪些类型的数据？

流程：

1. 引入AIDL 的相关类.; 2. 调用aidl 产生的class.

数据类型：

理论上, 参数可以传递基本数据类型和String, 还有就是Bundle 的派生类, 不过在Eclipse 中,目前的ADT 不支持 Bundle 做为参数。

## 四、Android 中的事件处理

### 1、Handler 机制（★★★★★）

​	Android 中主线程也叫 UI 线程，那么从名字上我们也知道主线程主要是用来创建、更新 UI 的，而其他耗时操作，比如网络访问，或者文件处理，多媒体处理等都需要在子线程中操作，之所以在子线程中操作是为了保证 UI 的流畅程度，手机显示的刷新频率是 60Hz，也就是一秒钟刷新 60 次，每 16.67 毫秒刷新一次，为了不丢帧，那么主线程处理代码最好不要超过 16 毫秒。当子线程处理完数据后，为了防止 UI 处理逻辑的混乱，Android 只允许主线程修改 UI，那么这时候就需要 Handler 来充当子线程和主线程之间的桥梁了。
​	我们通常将 Handler 声明在 Activity 中， 然后覆写 Handler 中的handleMessage方法 , 当子线程调用handler.sendMessage()方法后handleMessage 方法就会在主线程中执行。

​	这里面除了 Handler、Message 外还有隐藏的 Looper 和 MessageQueue 对象。

​	在主线程中 Android 默认已经调用了 Looper.prepare()方法，调用该方法的目的是在 Looper 中创建MessageQueue 成员变量并把Looper 对象绑定到当前线程中。当调用 Handler 的 sendMessage（对象）方法的时候就将 Message 对象添加到了 Looper 创建的MessageQueue 队列中，同时给 Message 指定了 target 对象，其实这个 target 对象就是 Handler 对象。主线程默认执行了Looper.looper（）方法，该方法从 Looper 的成员变量 MessageQueue 中取出 Message，然后调用 Message 的 target 对象的 handleMessage()方法。这样就完成了整个消息机制。

### 2、事件分发机制（★★★★★）

1.   #### 事件分发中的onTouch 和onTouchEvent 有什么区别，又该如何使用？

     -   onTouch()方法是View.OnTouchListener接口中定义的，该方法在触摸事件发生时被调用。当View注册了OnTouchListener接口，并且用户触摸了这个View时，onTouch()方法会被调用。在这个方法中，我们可以获取到MotionEvent对象，从而对触摸事件做出相应的处理。同时，我们可以返回一个布尔值来指示是否消费该事件。如果返回true，表示消费该事件，否则将该事件传递给下一个处理方法。

     -   onTouchEvent()方法是View类中定义的，该方法是事件分发机制中的最后一环。当触摸事件到达View时，onTouchEvent()方法将被调用。在这个方法中，我们可以获取到MotionEvent对象，并根据该事件做出相应的处理。同时，我们可以返回一个布尔值来指示是否消费该事件。如果返回true，表示消费该事件，否则该事件将被传递给父View或Activity处理。

     -   总的来说，onTouch()和onTouchEvent()方法的主要区别在于事件传递的层级和消费方式。onTouch()方法可以在事件分发的任何阶段进行处理，并可以决定是否消费该事件；而onTouchEvent()方法是最后一环，只有当所有的事件处理方法都没有消费该事件时，才会传递到这个方法。因此，onTouch()方法可以用于特定的场景，例如对多个View进行手势识别；而onTouchEvent()方法通常用于处理最终的触摸事件，例如在View中实现点击、长按、滑动等操作。

     -   需要注意的是，当我们同时在View中实现了onTouch()和onTouchEvent()方法时，优先调用onTouch()方法。如果onTouch()方法返回false，则会调用onTouchEvent()方法。因此，我们可以根据自己的需求来选择使用哪个方法，并结合返回值来控制事件的传递和消费。

2.   #### 请描述一下Android 的事件分发机制

     ![image-20230327001516710](https://cdn.jsdelivr.net/gh/ChengYang1998/blogImage@main/PicGo/image-20230327001516710.png)

     可以概括为以下几个步骤：

     1.  事件的产生：当用户在屏幕上进行触摸或其他操作时，操作系统会根据触摸坐标和时间戳等信息生成一个事件。
     2.  事件的传递：事件从操作系统传递到当前Activity的最上层ViewGroup，并依次传递给它的子View和它们的回调方法，下 发 的 过 程 是 调 用 子 View(ViewGroup) 的dispatchTouchEvent 方法实现的。直到某个View的回调方法返回true或事件传递到了最底层的View，这个过程被称为事件的分发。分发的目的是为了找到真正要处理本次完整触摸事件的 View，这个 View 会在 onTouchEvent 结果返回 true。
     3.  事件的处理：当事件到达某个View时，会中止 Down 事件的分发， 同时在
         ViewGroup 中记录该子 View。View会根据事件类型调用对应的回调方法，例如onClick()、onLongClick()、onTouch()等。如果该回调方法返回true，表示事件已经被处理，事件传递结束。如果该回调方法返回false，事件会继续传递到父View或Activity的onTouchEvent()方法中。
     4.  事件的消费：如果事件传递到了最底层的View或者某个回调方法返回了true，表示该事件已经被消费，事件传递结束。如果事件没有被消费，则会传递给父View或Activity的onTouchEvent()方法中，直到事件被消费或者传递到了操作系统。

## 五、Android 中的动画

### 1、Android 中的动画有哪几类，它们的特点和区别是什么（★★★）

在Android中，常见的动画类型包括补间动画、帧动画和属性动画三种。

1.  补间动画（Tween Animation）：补间动画是一种比较基础的动画类型，它可以对View的某些属性进行动画处理，例如位移、缩放、旋转和透明度等。只能对View的特定属性进行处理，不能对多个属性进行组合处理，也不能实现任意属性的动画效果。
2.  帧动画（Frame Animation）：帧动画是一种比较简单的动画类型，它是通过逐帧播放一组预先定义好的图片来实现动画效果的。帧动画的特点是可以实现比较简单的动画效果，但是它只能播放预先定义好的图片，不能根据用户操作或其它因素动态生成动画效果。
3.  属性动画（Property Animation）：属性动画是一种比较高级和灵活的动画类型，它可以对View的任意属性进行动画处理，例如背景色、字体大小和View的自定义属性等。属性动画的特点是可以实现对View任意属性的动画处理，而且可以实现多个属性的组合动画，还可以通过设置动画插值器（Interpolator）来实现不同的动画效果。属性动画最常用的类是ValueAnimator和ObjectAnimator。

### 2、如何修改Activity 进入和退出动画（★★）

在Android中，可以通过在Activity的onCreate()和onDestroy()方法中设置Activity的进入和退出动画来实现动画效果的修改。具体步骤如下：

1.  在res目录下创建anim文件夹，分别创建进入和退出动画的xml文件，例如enter_anim.xml和exit_anim.xml。
2.  在enter_anim.xml中定义Activity进入时的动画效果，例如淡入效果：

```xml
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android"
    android:duration="500"
    android:interpolator="@android:anim/accelerate_interpolator">
    <alpha
        android:fromAlpha="0.0"
        android:toAlpha="1.0" />
</set>
```

1.  在exit_anim.xml中定义Activity退出时的动画效果，例如淡出效果：

```xml
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android"
    android:duration="500"
    android:interpolator="@android:anim/accelerate_interpolator">
    <alpha
        android:fromAlpha="1.0"
        android:toAlpha="0.0" />
</set>
```

2.  在Activity的onCreate()方法中调用overridePendingTransition()方法来设置Activity进入时的动画效果，例如：

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    overridePendingTransition(R.anim.enter_anim, 0);
}
```

其中，第一个参数为进入动画的资源id，第二个参数为退出动画的资源id，如果不需要设置退出动画，则设置为0即可。

3.  在Activity的onDestroy()方法中同样调用overridePendingTransition()方法来设置Activity退出时的动画效果，例如：

```java
@Override
protected void onDestroy() {
    super.onDestroy();
    overridePendingTransition(0, R.anim.exit_anim);
}
```

这样，我们就可以通过设置进入和退出动画的xml文件以及在Activity中调用overridePendingTransition()方法来修改Activity的进入和退出动画了。

### 3、属性动画，例如一个 button 从 A 移动到 B 点，B 点还是可以响应点击事件，这个原理是什么？（★★）

​	补间动画只是显示的位置变动，View 的实际位置未改变，表现为 View 移动到其他地方，点击事件仍在原处才能响应。而属性动画控件移动后事件相应就在控件移动后本身进行处理

## 六、ContentObserver 内容观察者

ContentObserver的作用是用于监视数据变化，例如ContentProvider中数据的变化、短信数据库中短信的变化等。当被观察的数据发生变化时，ContentObserver会收到通知，并可以在回调函数中进行相应的处理。由于ContentObserver是由系统负责调用的，因此它可以帮助我们实现后台数据的自动更新，从而提高应用程序的性能和用户体验。

ContentObserver的特点如下：

1.  监听范围：ContentObserver可以监听指定URI中的数据变化，例如ContentProvider中的数据变化、短信数据库中短信的变化等。
2.  异步通知：ContentObserver是异步通知的，即当被观察的数据发生变化时，系统会在主线程中通过Handler机制异步通知ContentObserver进行处理，避免了在UI线程中进行繁重的数据处理。
3.  生命周期：ContentObserver的生命周期由系统管理，当不再需要使用ContentObserver时，需要及时将其注销以释放资源，避免内存泄漏。
4.  注册方式：ContentObserver的注册方式是通过ContentResolver.registerContentObserver()方法进行注册，需要指定要监听的URI、是否监听子URI、以及ContentObserver的回调函数等参数。



# 第三章：Java基础

## 一、静态内部类和非静态内部类的比较

### 1.1 静态内部类和非静态内部类的区别

-   **是否依赖外部类的实例**

静态内部类和非静态内部类主要的不同：

1.   静态内部类不依赖于外部类实例而被实例化，但非静态内部类需要在外部类实例化后才可以被实例化
2.   静态内部类不需要持有外部类的引用。但非静态内部类需要持有对外部类的引用
3.   静态内部类不能访问外部类的非静态成员变量和非静态方法。他只能访问外部类的静态成员和静态方法，非静态内部类能够访问外部类的静态和非静态成员和方法

### 1.2扩展：内部类都有哪些？

有四种：静态内部类、非静态内部类、局部内部类、匿名内部类

### 1.3局部内部类

在外部类的方法中定义的类，其作用的范围是所在的方法内。他不能被public、private、protected来修饰。他只能访问方法中定义的final类型的局部变量。

### 1.4匿名内部类：是一种没有类名的内部类。

1.   匿名内部类一定是在new的后面，这个匿名内部类必须继承一个父类或实现一个接口
2.   匿名内部类不能有构造函数
3.   只能创建匿名内部类的一个实例
4.   在Java8之前，如果匿名内部类需要访问外部类的局部变量，则必须用final修饰外部类的局部变量。在现在Java8已结取消了这个限制。



## 二、多态的理解与应用

### 2.1多态概述

多态指的是同一种类型的对象，在不同的情况下表现出不同的行为。

-   多态体现为**父类引用变量可以指向子类对象**（⭐⭐⭐⭐⭐）

    同一种类型的对象，在不同的情况下表现出不同的行为

-   本质：**对象的实际类型和引用类型可以不一致，从而在不同的情况下表现出不同的行为。**

-   多态的定义与使用格式
    定义格式：**父类类型** 变量名 = new **子类类型**();

### 2.2多态中成员的特点

假设有一个父类Animal和一个子类Dog，Dog类覆盖了Animal类中的eat()方法，并新增了一个bark()方法。现在我们创建一个Dog对象并用Animal类型的引用变量引用它：

```java
Animal animal = new Dog();
```

由于animal的类型是Animal，因此它只能访问Animal类中的成员。但是由于实际对象是Dog，因此在调用eat()方法时会调用Dog类中覆盖了Animal类的eat()方法。如果我们尝试访问Dog类中新增的bark()方法，编译器会报错，因为animal的类型是Animal，无法访问Dog类中新增的成员。

```java
animal.eat(); // 调用Dog类中的eat()方法
animal.bark(); // 编译器报错，Animal类中不存在bark()方法
```

在Java中，**成员的访问特点取决于引用变量的类型**，**而具体调用的方法实现取决于对象的实际类型**。在多态的情况下，编译器只能根据引用变量的类型来确定访问哪些成员，因此**无法访问子类新增的成员**。但是在运行时，实际上调用的方法是由对象的实际类型决定的，这是Java中动态绑定的特性。

### 2.3instanceof关键字

作用：用来判断某个对象是否属于某种数据类型,返回类型为布尔类型

```java
Object obj = new String("Hello, World!");
if (obj instanceof String) {
    // obj是String类的实例
} else {
    // obj不是String类的实例
}
```

### 2.4多态的转型

-   多态的转型分为向上转型和向下转型两种

-   向上转型：多态本身就是向上转型过的过程
    使用格式：`Animal animal = new Dog();`

    适用场景：当不需要面对子类类型时，通过提高扩展性，或者使用父
    类的功能就能完成相应的操作。

-   向下转型：一个已经向上转型的子类对象可以使用强制类型转换的格
    式，将父类引用类型转为子类引用各类型

    ```java
    Animal animal = new Dog(); // 父类引用指向子类对象
    if (animal instanceof Dog) {
        Dog dog = (Dog) animal; // 向下转型为Dog类型的引用变量
        dog.bark(); // 调用Dog类的成员方法
    } else {
        System.out.println("animal is not a Dog");
    }
    ```

## 三、java方法的多态性理解

多态存在的三个必要条件：

1.   要有继承；
2.   要有重写；
3.   父类引用指向子类对象。

多态的好处：可扩展、可替换，代码灵活可复用

### 3.1 java多态分类

在Java中，多态主要分为两种：编译时多态（静态多态）和运行时多态（动态多态）。

-   编译时多态

    是指在编译时就能确定方法的调用对象和参数类型，这种多态也称为静态多态。例如**方法的重载（Overload）**就是一种编译时多态，因为编译器可以根据方法的参数类型在编译时确定要调用的方法。

-   运行时多态

    是指在程序运行时才能确定方法的调用对象和参数类型，这种多态也称为动态多态。例如**方法的重写（Override）**就是一种运行时多态，因为具体调用哪个方法是在程序运行时才能确定的，取决于对象的实际类型。

### 3.2 运行时多态

运行时多态的实现是**通过Java中的虚拟方法表（Virtual Method Table）来实现**的。每个对象在运行时都会有一个虚拟方法表，**表中记录了该对象所属类的所有方法的地址**。当调用一个方法时，实际上是通过该对象的虚拟方法表来查找该方法的地址，然后调用该地址对应的方法。

在Java中，运行时多态的实现是通过Java虚拟机（JVM）在内存中创建的虚拟方法表来实现的，当调用一个对象的方法时，JVM会根据对象的实际类型在虚拟方法表中查找对应的方法实现，以实现多态性的调用。因此，动态绑定和Java虚拟机中的虚拟方法表是紧密相关的概念。

### 3.3 代码理解

1.   运行时多态是在父类引用指向子类对象时产生的。一个父类的引用可以指向多种子类对象，那么运行时对于同一个消息应该如何做出响应呢？

     由运行时实际的被引用的对象的类型来决定。**这就是运行时多态的动态绑定**。

2.   为什么要有重写呢？难道父类中的方法没有被重写，直接调用子类中存在的方法难道是不行吗？

     如果不进行重写，运行时调用的仍然是父类中的方法，而不是子类中的方法。无法实现对子类进行定制化的操作，无法实现多态性。

3.   为什么要有继承？

     没有继承，就没有重写。

### 3.4 方法调用的优先问题

`this.show(O) > super.show(O) > super.show((super)O) > this.show((super)O)`

在Java中，方法调用的优先顺序是先查找子类中是否有对应的方法，如果没有再查找父类中是否有对应的方法。如果父类和子类中都有同名的方法，子类中的方法会覆盖父类中的方法，即子类的方法会被调用。

## 四、java中接口和继承的区别

1.  继承可以在子类中直接使用父类的属性和方法，而接口只是定义了一组规范，要实现接口中定义的方法才能使用。
2.  类只能单继承，而接口可以实现多个，一个类可以实现多个接口。
3.  继承是is-a关系，子类是父类的一种特殊形式，而接口是has-a关系，表示一个类具有某些特定的能力或行为。
4.  接口中定义的方法默认都是public和abstract类型，而继承中的方法访问权限和实现方式受到父类的限制。
5.  接口中不能包含成员变量，而继承中可以包含。

总的来说，继承主要用于**描述类与类之间的关系**，而接口则用于**描述类具有的特定行为和能力**。

## 五、线程池的好处，详解，单例

### 5.1线程池的好处



1.   #### 线程池的重用

     线程的创建和销毁的开销是巨大的，而通过线程池的重用大大减少了这些不必要的开销，当然既然少了这么多消费内存的开销，其线程执行速度也是突飞猛进的提升。
   
2.   #### 控制线程池的并发数

     **并发**：在某个时间段内，多个程序都处在执行和执行完毕之间；但在一个时间点上只有一个程序在运行。
     
     **并行**：在某个时间段里，每个程序按照自己独立异步的速度执行，程序之间互不干扰。
     
     回到线程池，控制线程池的并发数可以有效的避免大量的线程池争夺CPU资源而造成堵塞。
     
3.   #### 线程池可以对线程进行管理

     线程池可以提供定时、定期、单线程、并发数控制等功能。比如通过ScheduledThreadPool线程池来执行S秒后，每隔N秒执行一次的任务。

### 5.2线程池的详解

`ThreadPoolExecutor`是Java中用于创建线程池的类，通过这个类可以方便地管理多线程任务的执行。

`ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue)`

| `ThreadPoolExecutor()`参数 | 说明                                                         |
| -------------------------- | ------------------------------------------------------------ |
| corePoolSize               | 核心线程池大小，表示保持活动状态的线程数，即使它们处于空闲状态也不会被销毁 |
| maximumPoolSize            | 线程池最大允许的线程数                                       |
| keepAliveTime              | 非核心线程闲置超时时间，超过这个时间就会被回收               |
| unit                       | `keepAliveTime`的时间单位，有纳秒、微秒、毫秒、秒、分、时、天等。 |
| workQueue                  | 等待队列，用于存储等待执行的任务                             |
| threadFactory              | 为线程池提供创建新线程的功能，这个我们一般使用默认即可       |
| handler)                   | 拒绝策略，当线程无法执行新任务时                             |

1.   当currentSize<corePoolSize时，直接启动一个核心线程并执行任务。
2.   当currentSize>=corePoolSize、并且workQueue未满时，添加进来的任务会被安排到workQueue中等待执行。
3.   当workQueue已满，但是currentSize<maximumPoolSize时，会立即开启一个非核心线程来执行任务。
4.   当currentSize>=corePoolSize、workQueue已满、并且currentSize>maximumPoolSize时，调用handler默认抛出RejectExecutionExpection异常。

其他线程池：

1.   **FixedThreadPool**:

     Fixed中文解释为**固定**。有固定数量线程的线程池。其corePoolSize=maximumPoolSize，且keepAliveTime为0，适合线程稳定的场所。

2.   **SingleThreadPool**:

     Single中文解释为单一。有固定数量线程的线程池，且数量为一，从数学的角度来看SingleThreadPool应该属于FixedThreadPool的子集。其corePoolSize=maximumPoolSize=1,且keepAliveTime为0，适合线程同步操作的场所。

3.   **CachedThreadPool**:

     Cached中文解释为储存。结合在一起解释储存的线程池，既然要储存，其容量肯定是很大，所以他corePoolSize=0（线程数会根据任务的数量自动增减），maximumPoolSize=Integer.MAX_VALUE。

4.   **ScheduledThreadPool**:

     Scheduled中文解释为计划。结合在一起解释计划的线程池，顾名思义既然涉及到计划，必然会涉及到时间。所以ScheduledThreadPool是一个具有定时定期执行任务功能的线程池。

### 5.3线程池的单例

-   #### 单例

​	单例是一种设计模式，用于确保一个类只有一个实例，并提供全局访问该实例的方式。在单例模式中，类的构造函数被私有化，防止外部直接创建实例，而是提供一个静态方法返回类的唯一实例。这种方式可以确保在整个应用程序中只有一个实例，避免了多个实例之间的资源竞争和数据不一致问题，也提高了代码的可维护性和可扩展性。

-   #### 注意事项：

1.   单例类只能有一个实例。
2.   单例类必须自己创建自己的唯一实例。
3.   单例类必须给所有其他对象提供这一实例。

-   #### 线程池的单例

Q：为什么要将线程池设计成单例模式呢。

A：一般情况下，整个系统中只需要单种线程池，多个线程公用一个线程池，不会是每创一个线程就要创建一个线程池，那样子还不如不用线程池呢。

实现：

```java
public class MyThreadPool {
    private static MyThreadPool mThreadPool = null; // 单例实例
    private ExecutorService fixedThreadPool; // 线程池对象

    // 私有构造函数，确保外部无法直接实例化该类
    private MyThreadPool() {
        // 创建一个拥有5个线程的FixedThreadPool线程池
        fixedThreadPool = Executors.newFixedThreadPool(5);
    }

    // 获取单例实例的静态方法
    public static MyThreadPool getThreadPool() {
        // 双重校验锁，确保多线程下只创建一个实例
        if (mThreadPool == null) {
            synchronized (MyThreadPool.class) {
                if (mThreadPool == null) {
                    mThreadPool = new MyThreadPool();
                }
            }
        }
        return mThreadPool;
    }

    // 提交任务到线程池
    public void execute(Runnable task) {
        fixedThreadPool.execute(task);
    }

    // 关闭线程池
    public void shutdown() {
        fixedThreadPool.shutdown();
    }
}
```

## 六、线程池的优点及其原理

### 6.1 使用线程池的好处

-   池化技术应用：线程池、数据库连接池、http连接池等。

-   目的：减少每次获取资源的消耗，提高对资源的利用率。
-   线程池提供了一种**限制、管理资源的策略**。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。

### 6.2 Executor框架

Executor框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，让并发编程变得更加简单。
Executor框架的使用示意图：

<img src="https://cdn.jsdelivr.net/gh/ChengYang1998/blogImage@main/PicGo/image-20230329161656103.png" alt="image-20230329161656103" style="zoom: 67%;" />

线程池分析原理：

<img src="https://cdn.jsdelivr.net/gh/ChengYang1998/blogImage@main/PicGo/image-20230329161755047.png" alt="image-20230329161755047" style="zoom:80%;" />

### 6.3 线程池大小确定

有一个简单且使用面比较广的公式：

-   CPU密集型任务（N+1）：

    这种任务消耗的主要是CPU资源，可以将线程数设置为N（CPU核心数）+1，比CPU核心数多出来一个线程是为了防止线程偶发的缺页中断，或者其他原因导致的任务暂停而带来的影响。一旦任务停止，CPU就会出于空闲状态，而这种情况下多出来一个线程就可以充分利用CPU的空闲时间。

-   I/O密集型（2N）：

    这种任务应用起来，系统大部分时间用来处理I/O交互，而线程在处理I/O的时间段内不会占用CPU来处理，这时就可
    以将CPU交出给其他线程使用。因此在I/O密集型任务的应用中，可以配置多一些线程。

## 七、 重复 略

## 八、 为什么不推荐通过Executors直接创建线程池



### 1.缓存队列 LinkedBlockingQueue 没有设置固定容量大小

当任务量过大时，可能会导致队列无限增长，耗尽系统内存，应该使用有界队列或自定义队列来避免这个问题。

### 2.最大线程数量是 Integer.MAX_VALUE

导致系统资源被耗尽

### 3.线程池拒绝策略不合理

不支持自定义拒绝策略，使用的是 ThreadPoolExecutor 的默认策略，即 AbortPolicy



## 九、 BlockingQueue及其实现

### 9.1 前言

BlockingQueue是Java中一个非常重要的并发工具，用于在多线程情况下，实现线程之间的通信和协作。

-   它是一个支持阻塞操作的队列，可以保证在队列为空或满时，插入和删除操作的阻塞等待。
-   能够避免一些并发问题的产生，如死锁等。
-   在Android开发中，BlockingQueue也是一个非常重要的工具，它被广泛应用于线程池、消息队列、任务队列等场景中，用于协调多个线程的执行。

其最常用的还是用于实现生产者与消费者模式，大致如下图所示：

![image-20230329164508906](https://cdn.jsdelivr.net/gh/ChengYang1998/blogImage@main/PicGo/image-20230329164508906.png)

>   在Java中，BlockingQueue是一个接口，它的实现类有ArrayBlockingQueue、DelayQueue、 LinkedBlockingDeque、LinkedBlockingQueue、PriorityBlockingQueue、SynchronousQueue等，它们的区别主要体现在存储结构上或对元素操作上的不同，但是对于take与put操作的原理，却是类似的。

### 9.2 阻塞与非阻塞

| 方法                                    | 阻塞/非阻塞 | 当队列满时                   | 当队列空时                  |
| --------------------------------------- | ----------- | ---------------------------- | --------------------------- |
| add(E e)                                | 非阻塞      | 抛出异常                     | -                           |
| offer(E e)                              | 非阻塞      | 返回 false                   | -                           |
| put(E e)                                | 阻塞        | 阻塞等待空闲队列             | -                           |
| offer(E e, long timeout, TimeUnit unit) | 阻塞        | 等待指定时间，超时返回 false | -                           |
| take()                                  | 阻塞        | -                            | 阻塞等待非空队列            |
| poll(long timeout, TimeUnit unit)       | 阻塞        | -                            | 等待指定时间，超时返回 null |
| poll()                                  | 非阻塞      | 返回 null                    | -                           |

对于阻塞式的入队和出队，BlockingQueue提供了put()和take()方法，put()方法会在队列满时进行阻塞等待，直到队列有空位才能成功添加元素，take()方法则会在队列为空时进行阻塞等待，直到队列中有元素时才能取出并返回。

相反，非阻塞式的入队和出队操作则是通过offer()和poll()方法实现的。offer()方法会尝试将元素添加到队列中，如果队列已满则会返回false，而poll()方法会尝试从队列中获取元素，如果队列为空则会返回null。

### 9.3 LinkedBlockingQueue 源码分析

-   LinkedBlockingQueue是一个基于链表实现的可选容量的阻塞队列。队头的元素是插入时间最长的，队尾的元素是最新插入的。新的元素将会被插入到队列的尾部。
-   LinkedBlockingQueue的容量限制是可选的，如果在初始化时没有指定容量，那么默认使用int的最大值作为队列容量。

底层数据结构:
LinkedBlockingQueue内部是使用链表实现一个队列的，但是却有别于一般的队列，在于该队列至少有一个节点，头节点不含有元素。结构图如下：

![image-20230329165434939](https://cdn.jsdelivr.net/gh/ChengYang1998/blogImage@main/PicGo/image-20230329165434939.png)

-   LinkedBlockingQueue中维持两把锁，一把锁用于入队，一把锁用于出队，这也就意味着，同一时刻，只能有一个线程执行入队，其余执行入队的线程将会被阻塞；同时，可以有另一个线程执行出队，其余执行出队的线程将会被阻塞。

-   换句话说，虽然入队和出队两个操作同时均只能有一个线程操作，但是可以一个入队线程和一个出队线程共同执行，也就意味着可能同时有两个线程在操作队列。

-   那么为了维持线程安全，LinkedBlockingQueue使用一个AtomicInterger类型的变量表示当前队列中含有的元素个数，所以可以确保两个线程之间操作底层队列是线程安全的。

    AtomicInterger类型的变量：多线程下对该变量的操作都必须是是原子性的。

### 9.4ArrayBlockingQueue源码分析

-   ArrayBlockingQueue底层是使用一个数组实现队列的
-   在构造ArrayBlockingQueue时需要指定容量，也就意味着底层数组一旦创建了，容量就不能改变了，因此ArrayBlockingQueue是一个容量限制的阻塞队列。
-   因此，在队列全满时执行入队将会阻塞，在队列为空时出队同样将会阻塞。

ArrayBlockingQueue的并发阻塞是通过ReentrantLock和Condition来实现的，ArrayBlockingQueue内部**只有一把锁**，意味着**同一时刻只有一个线程**能进行入队或者出队的操作。

### 9.5 总结

-   ArrayBlockingQueue：

    -   一个对象数组 + 一把锁 + 两个条件
    -   入队与出队都用同一把锁。

    -   在只有入队高并发或出队高并发的情况下，因为操作数组，且不需要扩容，性能很高。
    -   采用了数组，必须指定大小，即容量有限。

-   LinkedBlockingQueue：
    -   一个单向链表 + 两把锁 + 两个条件
    -   两把锁，一把用于入队，一把用于出队，有效的避免了入队与出队时使用一把锁带来的竞争。
    -   在入队与出队都高并发的情况下，性能比ArrayBlockingQueue高很多。
    -   采用了链表，最大容量为整数最大值，可看做容量无限。

## 十、深入理解ReentrantLock与Condition

### 10.1 锁的概念

锁（Lock）是一种同步机制，它用于保护多个线程访问共享资源时的互斥和可见性。当一个线程获得锁时，其他线程无法访问该锁保护的共享资源，直到该线程释放锁。

例如，一个银行账户有多个线程同时访问，如果没有锁保护，可能会出现多个线程同时修改余额导致数据不一致的问题。使用锁可以确保同一时刻只有一个线程能够访问该账户，保证了数据的正确性。常见的锁包括 synchronized 关键字和 ReentrantLock 类。

<img src="https://cdn.jsdelivr.net/gh/ChengYang1998/blogImage@main/PicGo/image-20230329171207257.png" alt="image-20230329171207257" style="zoom:80%;" />

### 10.2 锁的使用

```java
public class FirstReentrantLock {
    
    public static void main(String\[\] args) {
        Runnable runnable = new ReentrantLockThread();
        new Thread(runnable, "a").start();
        new Thread(runnable, "b").start();
    }
}
class ReentrantLockThread implements Runnable {

    @Override
    public void run() {
        for (int i = 0; i < 3; i++) {
            System.out.println(Thread.currentThread().getName() + "输出了： " + i);
        }
    }
}
```

输出结果由多种可能：

```css
a输出了：0
a输出了：1
a输出了：2
b输出了：0
b输出了：1
b输出了：2
```

或者：

```css
b输出了：0
a输出了：0
b输出了：1
a输出了：1
a输出了：2
b输出了：2
```

那使用ReentrantLock加入锁，代码如下：

```java
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockDemo {
    private static ReentrantLock lock = new ReentrantLock(); // 创建一个可重入锁对象

    public static void main(String[] args) {
        Runnable runnable = new ReentrantLockThread();
        new Thread(runnable, "a").start();
        new Thread(runnable, "b").start();
    }

    static class ReentrantLockThread implements Runnable {
        @Override
        public void run() {
            lock.lock(); // 获取锁
            try {
                for (int i = 0; i < 3; i++) {
                    System.out.println(Thread.currentThread().getName() + "输出了： " + i);
                }
            } finally {
                lock.unlock(); // 释放锁
            }
        }
    }
}
```

1.  创建一个可重入锁对象： `private static ReentrantLock lock = new ReentrantLock();`
2.  在 `run()` 方法中调用 `lock()` 方法获取锁，保证多线程之间的互斥执行。
3.  在 try-finally 代码块中调用 `unlock()` 方法释放锁。

通过这样的操作，我们就可以保证多个线程之间互斥地访问临界区代码，避免了数据的并发问题。

### 10.3 使用Condition实现线程等待和唤醒

相比于synchronized的wait()、notify()、notifyAll()的机制，Condition的区别主要体现在以下几个方面：

1.  精准通知机制：Condition可以指定唤醒哪些线程，而synchronized的notify()、notifyAll()会随机唤醒等待线程，可能会引发虚假唤醒问题。
2.  多路等待机制：一个对象上只能有一个监视器锁，而Condition可以创建多个等待队列，一个Condition对象可以对应多个等待队列，一个线程可以注册到多个等待队列中。
3.  等待超时机制：Condition提供了await(long time, TimeUnit unit)方法，可以设置等待超时时间，避免线程无限等待。
4.  可以替代Object的wait()/notify()/notifyAll()等方法，提供了更灵活的线程同步方式，支持更多场景的应用。

使用：

```java
public class ConditionExample {

    // 实例化一个ReentrantLock对象
    private final ReentrantLock lock = new ReentrantLock();
    // 为线程注册一个Condition
    private final Condition condition = lock.newCondition();

    public void exampleMethod() {
        lock.lock();
        try {
            while (someConditionIsNotMet()) {
                // 在条件不满足的情况下等待
                condition.await();
            }
            // 执行一些操作
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            lock.unlock();
        }
    }

    public void someOtherMethod() {
        lock.lock();
        try {
            // 执行一些操作，改变条件
            // 使用了condition.signalAll()方法来通知其他正在等待的线程条件已经满足。
            condition.signalAll();	
        } finally {
            lock.unlock();
        }
    }

    private boolean someConditionIsNotMet() {
        // 判断某些条件是否满足，不满足返回false
        return true;
    }
}
```

在这个示例中，`exampleMethod`方法中，线程会在条件不满足的情况下等待，使用了`condition.await()`方法。而在`someOtherMethod`方法中，线程执行某些操作，改变了条件，并使用了`condition.signalAll()`方法来通知其他正在等待的线程条件已经满足。

- 学会使用Condition,那来用它实现生产者消费者模式

### 10.4 生产者和消费者

使用Condition实现生产者消费者模式的代码示例：

```java
/**
 * 使用Condition实现生产者消费者模式
 */
public class ProducerConsumerWithCondition {
    private static final int CAPACITY = 5; // 缓冲区大小
    private static final Queue<Integer> queue = new LinkedList<>(); // 缓冲区
    private static final Random random = new Random(); // 随机数生成器
    private static final Lock lock = new ReentrantLock(); // 锁对象
    private static final Condition notFull = lock.newCondition(); // 缓冲区不满条件
    private static final Condition notEmpty = lock.newCondition(); // 缓冲区不空条件

    /**
     * 生产者线程
     */
    static class Producer implements Runnable {
        @Override
        public void run() {
            while (true) {
                lock.lock(); // 获取锁
                try {
                    while (queue.size() == CAPACITY) { // 缓冲区已满，等待
                        System.out.println("缓冲区已满，生产者线程等待");
                        notFull.await();
                    }
                    int num = random.nextInt(10); // 生成随机数
                    queue.offer(num); // 放入缓冲区
                    System.out.println("生产者线程生产数据：" + num);
                    notEmpty.signal(); // 唤醒一个等待的消费者线程
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    lock.unlock(); // 释放锁
                }
            }
        }
    }

    /**
     * 消费者线程
     */
    static class Consumer implements Runnable {
        @Override
        public void run() {
            while (true) {
                lock.lock(); // 获取锁
                try {
                    while (queue.isEmpty()) { // 缓冲区为空，等待
                        System.out.println("缓冲区为空，消费者线程等待");
                        notEmpty.await();
                    }
                    int num = queue.poll(); // 从缓冲区取出数据
                    System.out.println("消费者线程消费数据：" + num);
                    notFull.signal(); // 唤醒一个等待的生产者线程
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    lock.unlock(); // 释放锁
                }
            }
        }
    }

    public static void main(String[] args) {
        Thread producerThread = new Thread(new Producer());
        Thread consumerThread = new Thread(new Consumer());
        producerThread.start();
        consumerThread.start();
    }
}

```

以上代码实现了一个基本的生产者消费者模式，生产者和消费者共享一个缓冲区，当缓冲区满时生产者线程会等待，当缓冲区为空时消费者线程会等待，等待条件通过Condition对象的await()方法实现，通过signal()方法唤醒等待线程。这种方式比较灵活，生产者和消费者可以有不同的等待条件，例如，生产者可以在缓冲区达到一定数量后等待，而消费者可以在缓冲区为空时等待。而且，使用Condition可以实现更加复杂的等待通知机制，例如，使用多个Condition对象对不同的等待条件进行管理，实现更加细粒度的控制。同时，使用Condition可以在等待过程中响应中断，可以更加精确地控制线程的生命周期。

总的来说，Condition是一种比较高级的线程间通信机制，可以更加灵活地控制线程的执行顺序和协作。

## 十一、Synchronized 关键字原理

### 11.1 概念

- Synchronized关键字解决的是多个线程之间访问资源的同步性

- 可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。

常用方式：

- 修饰代码块，即同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象。
- 修饰普通方法，即同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象。
- 修饰静态方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象。

具体使用规则如下：

![image-20230329210134062](https://cdn.jsdelivr.net/gh/ChengYang1998/blogImage@main/PicGo/image-20230329210134062.png)

### 11.2 Synchronized 原理

在Java虚拟机内部，每一个对象都有一个关联的监视器（Monitor），当使用Synchronized关键字修饰一个方法或代码块时，实际上是利用了监视器来实现线程的同步。

在方法或代码块被Synchronized修饰后，Java虚拟机会将方法或代码块内部加上一个监视器锁（Monitor Lock），即进入同步状态。在同步状态下，其他线程想要执行相应的方法或代码块，需要先获得该对象的监视器锁。

在进入同步状态时，Java虚拟机会首先尝试获取对象的监视器锁。如果该对象的监视器锁没有被其他线程持有，则获得锁，并进入同步状态。如果监视器锁被其他线程持有，则进入阻塞状态，等待获得锁。

当一个线程获得了对象的监视器锁后，它可以执行方法或代码块，也可以调用wait()方法进入等待状态，此时它会释放监视器锁。其他线程可以获得该对象的监视器锁，并执行方法或代码块，直到该线程调用notify()或notifyAll()方法，唤醒一个或所有等待的线程。被唤醒的线程重新进入就绪状态，等待获取对象的监视器锁，然后继续执行。

在Synchronized的实现中，锁的获取和释放是由Java虚拟机自动完成的，这样可以避免程序员手动实现锁的获取和释放，从而降低了程序员的复杂度和出错的可能性。

![image-20230329210710653](https://cdn.jsdelivr.net/gh/ChengYang1998/blogImage@main/PicGo/image-20230329210710653.png)

synchronized的特点：

![image-20230329210751588](https://cdn.jsdelivr.net/gh/ChengYang1998/blogImage@main/PicGo/image-20230329210751588.png)

### 11.3 Synchronized 优化

从synchronized的特点中可以看到它是一种重量级锁，会涉及到操作系统状态的切换影响效率，所以JDK1.6中对synchronized进行了各种优化，为了能减少获取和释放锁带来的消耗引入了偏向锁和轻量锁。

12.3.1 偏向锁

在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径

12.3.2 轻量锁

在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。



### 11.4 扩展

#### 11.4.1 Synchronized 和 ReenTrantLock 的对比

1. 两者都是可重入锁
2. synchronized依赖于JVM 而ReenTrantLock依赖于API
3. ReenTrantLock比synchronized增加了一些高级功能
    相比synchronized，ReenTrantLock增加了一些高级功能。主要来说主要有三点：
    1. 等待可中断；
    2. 可实现公平锁；
    3. 可实现选择性通知（锁可以绑定多个条件）

#### 11.4.2 Synchronized 与 ThreadLocal 的对比

Synchronized 与 ThreadLocal的比较：

1. Synchronized关键字主要解决多线程共享数据同步问题；
    ThreadLocal主要解决多线程中数据因并发产生不一致问题。

2. Synchronized是利用锁的机制，使变量或代码块只能被一个线程访问。

  而ThreadLocal为每一个线程都提供变量的副本，使得每个线程访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。

## 十二、Java多线程：线程间通信之Lock

#### 12.1 synchronized的缺陷

思考一个情景，当多线程读写文件时，读操作和写操作会发生冲突，写操作和写操作会发生冲突，但读操作和读操作不会有冲突。如果使用synchronized来修饰的话，就很可能造成多个读操作无法同时进行的可能。此时就需要用到Lock，换言之Lock比synchronized提供了更多的功能。

使用Lock需要注意以下两点：

1. Lock不是语言内置的，synchronized是Java关键字，为内置特性，Lock是一个类，通过这个类可以实现同步访问。
2. 采用synchronized时我们不需要手动去控制加锁和释放，系统会自动控制。而使用Lock类，我们需要手动的加锁和释放，不主动释放可能会造成死锁。实际上Lock类的使用某种意义上讲要比synchronized更
    加直观。

#### 11.2 Lock类接口设计

以下是一个使用`Lock`类的例子，实现了线程安全的计数器：

```java
public class Counter {
    private int count = 0;
    private Lock lock = new ReentrantLock();

    public void increment() {
        lock.lock(); // 获取锁
        try {
            count++;
        } finally {
            lock.unlock(); // 释放锁
        }
    }

    public int getCount() {
        return count;
    }
}
```

​	在上面的例子中，`ReentrantLock`类是`Lock`接口的一种实现，用于实现可重入锁。通过使用`lock()`方法获取锁，在`try-finally`块中执行需要保护的代码，最后使用`unlock()`方法释放锁。这样就可以保证在同一时刻只有一个线程可以访问`increment()`方法，从而实现线程安全的计数器。

## 十三、ReentrantLock原理

ReentrantLock主要利用CAS+AQS队列来实现。它支持公平锁和非公平锁，两者的实现类似。

## 十四、HashMap中的Hash冲突解决和扩容机制

### 14.1 关于HashMap

- HashMap是Java中的一种数据结构，用于存储键值对。
- 它是基于哈希表实现的，可以快速地插入和查找元素。
- 在HashMap中，每个键都对应一个唯一的值，而且键和值都可以为null，HashMap允许最多一个key为null的记录。
- 它是非线程安全的，不支持并发访问。

- HashMap是一种散列表（Hash Table）数据结构，底层通过数组和链表或红黑树（JDK1.8之后）来实现。数组存储元素，链表或红黑树则用于解决哈希冲突。
- HashMap使用哈希函数对键进行哈希计算，得到的哈希值对数组的长度取模，得到对应的数组索引。如果该位置已有元素，则通过链表或红黑树继续存储。如果链表或红黑树的长度超过一定阈值，就会转化为红黑树，以提高查找效率。

**Hash冲突**是指在使用散列表时，由于不同的键值会被散列为相同的索引，导致冲突的情况。为了解决Hash冲突，通常有两种主要的方法：

1. 开放地址法：当发生冲突时，寻找下一个可用的散列桶。
2. 链地址法：在每个散列桶中维护一个链表，当发生冲突时，将键值对添加到链表中。

在Java中，HashMap使用的是链地址法来解决Hash冲突。当多个键值被映射到同一个散列桶时，它们会被存储在同一个链表中。

## 十五、 JVM常见面试题

### 15.1 说一下 JVM 的主要组成部分及其作用？（⭐⭐⭐⭐⭐）

![image-20230329213849589](https://cdn.jsdelivr.net/gh/ChengYang1998/blogImage@main/PicGo/image-20230329213849589.png)

JVM包含**两个子系统**和**两个组件**，

两个子系统为Class loader(类加载)、Execution engine(执行引擎)；

两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。

- Class loader(类加载)：负责加载Java类文件到JVM中，并生成对应的Class对象。
- Execution engine（执行引擎）：负责执行Java程序的字节码指令，将字节码翻译成机器指令并执行。
- Native Interface(本地接口)：为Java程序提供与其他编程语言交互的能力，例如在Java程序中调用C语言库。
- Runtime data area(运行时数据区域/内存区)：这就是我们常说的JVM的内存。

Java程序运行机制主要包括以下几个步骤：

<img src="https://cdn.jsdelivr.net/gh/ChengYang1998/blogImage@main/PicGo/image-20230329220053404.png" alt="image-20230329220053404"  />

1. 首先利用IDE集成开发工具编写Java源代码，源文件的后缀为.java；
2. 再利用编译器(javac命令)将源代码编译成字节码文件，字节码文件的后缀名为.class；
3. 运行字节码的工作是由解释器(java命令)来完成的。
4. 类加载器又将这些.class文件加载到JVM中。类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。

### 15.2 说一下 JVM 运行时数据区（⭐⭐⭐⭐⭐）

<img src="https://cdn.jsdelivr.net/gh/ChengYang1998/blogImage@main/PicGo/image-20230329220431952.png" alt="image-20230329220431952" style="zoom: 33%;" />

Java虚拟机规范中定义了5种内存区域，分别是：

1. 程序计数器（Program Counter Register）：用于记录当前线程所执行的字节码指令的地址。
2. Java虚拟机栈（Java Virtual Machine Stacks）：每个线程在创建时都会被分配一个Java虚拟机栈，用于存储方法的局部变量、操作数栈、动态链接、方法出口等信息。
3. 本地方法栈（Native Method Stack）：与Java虚拟机栈类似，不过是为虚拟机调用本地方法服务的。
4. Java堆（Java Heap）：用于存储对象实例，是Java虚拟机管理的内存区域中最大的一块。
5. 方法区（Method Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

其中，程序计数器、Java虚拟机栈和本地方法栈是线程私有的内存区域，而Java堆和方法区是线程共享的内存区域。

### 15.3 深拷贝和浅拷贝

- 浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址
- 深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存。新对象的属性值和原对象的属性值完全相同，但是新对象的属性是原对象属性的副本。

### 15.4 说一下堆栈的区别？

在Java中，堆和栈都是内存中的一块区域，主要用于存储变量。它们之间的区别如下：

1. **存储内容**：栈内存主要用来存储**方法调用**和**局部变量**，每个线程都有自己的栈空间，**栈中的变量在定义时就确定了大小和生命周期**，因此栈内存的大小和位置是固定的。而堆内存用来存储**对象及其成员变量**，对象在运行时动态创建和销毁，因此**堆内存的大小是不确定的**。
2. **分配方式**：栈内存的分配是由编译器自动完成的，它会自动分配内存并在函数执行完毕后自动释放。而堆内存的分配和释放需要程序员手动控制，通常使用**new关键字在堆内存中分配对象**。
3. 内存管理：栈内存的管理由系统自动完成，不需要程序员手动干预。而**堆内存的管理是由垃圾回收器自动完成**的，它会定期回收不再使用的对象来释放内存空间。
4. **访问速度**：栈内存的访问速度比堆内存快，因为它的分配和释放都是由编译器自动完成的，无需额外的操作。而堆内存的访问速度相对较慢，因为它需要在运行时进行动态分配和释放，而且还需要进行垃圾回收等操作。

### 15.5 JVM 面试题汇总

#### 15.5.1 JVM内存

##### 1、JVM方法区存储内容 是否会动态扩展，是否会出现内存溢出，出现的原因有哪些？

- JVM的方法区存储的是类信息、常量、静态变量、即时编译器编译后的代码等，一般不会动态扩展。但是，一些JVM实现（如HotSpot）将方法区实现为堆的一部分，因此方法区会随着堆的扩展而扩展。
- 方法区可能会出现内存溢出，一般是由于：
    - 加载的类、反射、动态代理等操作过多 导致 方法区中的元数据无法被垃圾回收器回收。
    - 动态生成的类太多

##### 2、JVM内存分为哪些区域？每个区域都存储哪些数据？一个对象从创建到销毁都是怎么在这些部分里存活和转移的？内存的哪些部分会参与GC的回收？（⭐⭐⭐⭐）

- 方法区、Java堆、Java堆虚拟机栈、本地方法栈、程序计数器

- | JVM内存区域  | 存储数据类型                                          |
    | ------------ | ----------------------------------------------------- |
    | 方法区       | 已被虚拟机加载的类信息、常量、静态变量等，线程共享    |
    | Java堆       | Java对象实例，线程共享                                |
    | Java虚拟机栈 | Java方法的局部变量、方法参数、返回值等，线程私有      |
    | 本地方法栈   | 用C/C++等语言编写的本地方法执行时的相关数据，线程私有 |
    | 程序计数器   | 记录当前线程执行的字节码指令的地址，线程私有          |

- 一个对象从创建到销毁的过程中，可能涉及到多个内存区域：

    1. 当对象被创建时，它的实例变量存储在Java堆中，引用变量存储在Java虚拟机栈或者本地方法栈中。
    2. 当方法调用时，方法需要在Java虚拟机栈中分配一定的空间，用于存储方法的参数、返回值和局部变量。
    3. 当方法中创建新的对象时，对象的实例变量存储在Java堆中，引用变量存储在Java虚拟机栈或者本地方法栈中。
    4. 当方法调用结束时，Java虚拟机栈中的栈帧被弹出，局部变量所占用的空间被释放。
    5. 当对象不再被引用时，Java堆中的对象实例被标记为可回收，在垃圾回收时被清除。

- 参与GC回收的内存区域主要包括**Java堆和方法区**。Java堆中的对象实例在没有引用时会被回收，方法区中的常量和类信息在没有引用时也会被回收。当Java堆中的对象实例无法被回收时，会出现内存泄漏，当方法区中的常量和类信息无法被回收时，会出现永久代溢出。

##### 3、JVM内存分代，Java 8的内存分代改进

​	JVM内存分代是指将Java堆内存分为不同的代，通常是年轻代、老年代和永久代，每一代都有其特定的用途和垃圾回收机制。

​	Java 8中的内存分代改进主要是将永久代替换为元空间（Metaspace），元空间和永久代不同之处在于，永久代使用的是JVM堆内存，而元空间使用的是本地内存，也就是直接使用操作系统的内存，因此不会出现永久代内存溢出的情况。此外，Java 8中对于年轻代和老年代的分配比例也进行了优化，使得内存分配更加高效。

#### 15.5.2 垃圾收集GC

##### 1、垃圾回收机制，包括GC的触发时机、回收策略和常见的垃圾回收算法。

- 垃圾回收（Garbage Collection，GC）是Java虚拟机自动进行的内存管理机制，用于释放无用对象所占用的内存空间，从而避免内存泄漏和程序运行异常。

- GC的触发时机由Java虚拟机自动判断。当Java堆内存不足时，Java虚拟机会自动触发垃圾回收。

- 两种基本的垃圾回收策略：**分代收集**和**标记-清除**

- 常见的垃圾回收算法有：复制算法、标记-清除算法、标记-整理算法、分代收集算法等。

- 复制算法：将堆内存分为两个区域，每次只使用其中一个区域，当该区域用完时，将其中存活的对象复制到另一个区域中，然后将原区域中所有对象清除。

    标记-清除算法：将堆内存分为已使用区域和未使用区域，当需要回收时，将已使用区域中所有未标记的对象清除。

    标记-整理算法：标记-整理算法是标记-清除算法的改进版。它将已使用区域中的所有存活对象向一端移动，然后将移动后端的未使用空间全部清除。

    分代收集算法：将堆内存分为年轻代和老年代，年轻代中的对象存活时间短，使用复制算法进行回收，老年代中的对象存活时间长，使用标记-清除或标记-整理

##### 2、常见的内存溢出和栈溢出的场景，以及如何处理内存溢出和栈溢出问题。

- 常见的内存溢出场景包括：
    1. **大量对象无法释放**。
    2. **循环引用**的对象，导致无法回收。
    3. 静态集合类（如List、Map）中存放大量数据（通常具有较长的生命周期），占用内存空间过大。
    4. 对象过大无法分配内存，如创建一个巨大的数组或字符串。
    5. 方法区（永久代）中存放的元数据过多，如大量的类或字符串常量。

- 常见的栈溢出场景包括：
    1. **递归调用层数过深**，导致栈空间被占满。
    2. 创建**大量的线程**，每个线程都有自己的Java虚拟栈空间。
    3. **方法内部定义的数组过大**，超出栈帧大小。

- 处理内存溢出问题的方法包括：
    1. **增加堆内存**空间或调整垃圾回收策略。
    2. 优化程序代码，尽量减少对象的创建和引用。
    3. 使用缓存机制，减少对象的创建和销毁次数。
    4. **使用弱引用、软引用、虚引用**等引用类型，协助垃圾回收。
    5. 对于无法避免的大对象，**使用对象池**等技术，重复利用已有对象。
    6. 对于内存泄漏问题，可以使用一些工具来检测和定位问题，如内存分析工具MAT等。

- 处理栈溢出问题的方法包括：
    1. 减少递归调用层数或者**优化递归算法**。
    2. **调整虚拟机栈大小**或者使用-Xss参数调整栈大小。
    3. 减少线程数量或者调整线程栈大小。
    4. 对于方法内部定义的数组过大的问题，可以**调整数组大小**或者将其拆分成多个数组。

##### 3、常用垃圾收集器。

常用的垃圾收集器包括G1收集器、CMS收集器、串行收集器和并行收集器等

##### 4、如何使用工具查看Java程序的内存占用情况，定位内存泄漏和垃圾回收问题。

1. Android Studio Profiler
2. LeakCanary
3. ADB

## 十六、JVM内存结构

## 十七、类加载机制/双亲委托

# 第五章 网络通信篇

当在浏览器中输入“baidu.com”并按下“回车”时，以下是大致的网络通信基本过程：

1.  当计算机需要解析“baidu.com”域名时，如果**本地DNS缓存**中没有该域名的IP地址，它会**检查操作系统的hosts文件**是否包含该域名的映射关系。如果该域名的映射关系存在于hosts文件中，则计算机将使用该IP地址进行域名解析。计算机将会继续向DNS服务器发送请求以获取IP地址。而且，如果hosts文件中的IP地址与DNS服务器返回的IP地址不同，则计算机会使用DNS服务器返回的IP地址进行域名解析，而不是使用hosts文件中的IP地址。

    具体请求流程：https://youtu.be/_618At72evs 【网络通信的基本过程，访问网站到底发生了什么事情？详细解析DNS原理】

2.  计算机使用获取到的IP地址建立与服务器的TCP连接。这是一个三次握手过程，用于确保双方都可以正常通信。

3.  计算机向服务器发送HTTP请求，请求服务器发送页面数据。

4.  服务器收到请求后，检索请求的资源并生成一个HTTP响应。响应包括状态码、头部信息和内容数据。

5.  服务器向您的计算机发送HTTP响应，其中包括请求的页面内容。

6.  计算机收到响应后，浏览器会解析响应内容并渲染网页。如果网页中包含其他资源，如图片、脚本等，浏览器会继续向服务器发送请求获取这些资源。

7.  通信完成后，计算机会关闭与服务器之间的TCP连接。

## 一、TCP连接

TCP连接是一个三次握手过程（⭐⭐⭐⭐⭐）

本质：在不可靠的信道上建立可靠的连接

1.  第一次握手（SYN）：客户端向服务器发送SYN报文，其中包含客户端的初始化序列号（ISN）以及要连接的端口号，此时客户端进入SYN_SEND状态。
2.  第二次握手（SYN+ACK）：服务器接收到客户端发送的SYN报文后，向客户端发送一个SYN+ACK报文作为响应，其中包含服务器的初始化序列号（ISN），确认号（ACK），以及确认客户端请求的端口号。此时服务器进入SYN_RECV状态。
3.  第三次握手（ACK）：客户端接收到服务器发送的SYN+ACK报文后，向服务器发送一个ACK报文作为响应，其中包含确认号（ACK），以及确认服务器请求的端口号。此时客户端进入ESTABLISHED状态，服务器也进入ESTABLISHED状态，TCP连接建立完成。

>   在三次握手过程中，每次握手都需要等待对方的响应，如果某次握手失败或超时，则需要重新开始握手过程，以确保双方建立连接成功。

解决**丢包问题**和**乱序问题**：

1.  **序列号和ACK号机制**：在TCP连接中，每个数据包都有一个唯一的序列号和确认号。发送方将数据包发送给接收方后，等待接收方的确认报文，如果接收方没有确认报文，发送方就会重新发送该数据包。通过序列号和确认号的交互，TCP可以检测并重传丢失的数据包，以确保数据传输的可靠性。
2.  **滑动窗口**机制：TCP协议还采用了滑动窗口机制来解决乱序问题。滑动窗口机制定义了一个窗口大小，表示接收方可以接收的数据包数量。发送方根据接收方窗口大小和确认号来判断可以发送的数据包数量和顺序，接收方则根据发送方发送的数据包的序列号来判断接收数据包的顺序。通过滑动窗口机制，TCP可以检测并恢复乱序数据包的顺序，以确保数据传输的有序性。
3.  **超时重传**机制：在TCP传输数据的过程中，如果一个数据包在一定时间内没有收到确认报文，发送方就会认为该数据包已经丢失，并进行重传。重传的时间间隔会逐渐增加，以避免网络拥塞。通过超时重传机制，TCP可以检测并重传丢失的数据包，以确保数据传输的可靠性。

TCP关闭连接是一个四次挥手过程（⭐⭐⭐⭐⭐）

假设是客户端发起断开连接请求：

1.  客户端发送FIN报文（FIN_WAIT_1状态）：客户端发送一个FIN报文，表示客户端已经没有数据要发送了，但仍然可以接收服务器发送的数据。
2.  服务器发送ACK报文（CLOSE_WAIT状态）：服务器接收到客户端的FIN报文后，发送一个ACK报文，表示服务器已经成功接收到客户端的FIN报文，并准备关闭连接。
3.  服务器发送FIN报文（LAST_ACK状态）：服务器发送一个FIN报文，表示服务器已经没有数据要发送了，并请求客户端关闭连接。
4.  客户端发送ACK报文（TIME_WAIT状态）：客户端接收到服务器的FIN报文后，发送一个ACK报文作为响应，表示客户端已经成功接收到服务器的FIN报文，并准备关闭连接。此时客户端进入TIME_WAIT状态，等待2倍的报文最大生存时间（2MSL）后才会彻底关闭连接。



## 二、HTTP请求

计算机向服务器发送HTTP请求，请求服务器发送页面资源。

https://www.bilibili.com/video/BV1KV411o7u5【前后端交互之 HTTP 协议】 

资源以**Url**形式进行定位，**Url**的结构：

<img src="https://cdn.jsdelivr.net/gh/ChengYang1998/blogImage@main/PicGo/image-20230330150811566.png" alt="image-20230330150811566" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ChengYang1998/blogImage@main/PicGo/image-20230330151141662.png" alt="image-20230330151141662" style="zoom:50%;" />

服务端收到Url会解析并返回相应数据。

<img src="https://cdn.jsdelivr.net/gh/ChengYang1998/blogImage@main/PicGo/image-20230330151255534.png" alt="image-20230330151255534" style="zoom:50%;" />

HTTP响应报文中可能包含的内容：

1.  HTTP协议版本：HTTP响应报文中包含了HTTP协议的版本，例如HTTP/1.1、HTTP/2.0等。
2.  状态码：HTTP响应报文中包含了一个状态码，用于表示服务器对客户端请求的处理结果。常见的状态码包括：100~199一般信息，200表示成功，301表示永久重定向，404表示资源不存在（客户端错误），500表示服务器内部错误等。
3.  响应头：HTTP响应报文中包含了一组响应头信息，用于描述服务器返回的数据类型、编码格式、长度、缓存策略、**Cookie**等内容。常见的响应头包括：Content-Type、Content-Encoding、Content-Length、Cache-Control等。
4.  响应体：HTTP响应报文中最重要的部分是响应体，它包含了服务器返回给客户端的实际内容。响应体的格式和内容根据不同的请求和响应类型而有所不同。例如，对于GET请求，响应体通常是请求的资源的实际内容；对于POST请求，响应体可能是一个确认消息或者其他的一些数据。比如：JSON字符串、JSON数组。

## 三、HTTPS请求

HTTPS则是在HTTP协议上加入了SSL/TLS加密层，数据在传输过程中进行加密处理，可以有效地保障数据的安全性。

TLS（Transport Layer Security）非对称加密过程如下：

1.  客户端向服务端发送加密请求，服务端返回自己的数字证书。
2.  客户端验证服务端的数字证书，确认服务端的身份和公钥。
3.  客户端生成一个随机的对称密钥，并使用服务端的公钥对该对称密钥进行加密，发送给服务端。
4.  服务端接收到加密后的对称密钥后，使用自己的私钥进行解密，得到客户端生成的对称密钥。
5.  客户端和服务端双方使用对称密钥进行加密通信，保证通信的安全性和完整性。

## 四、WebSocket

WebSocket 的最大特点就是：**服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话。**

TCP协议本身是一种面向连接、持久化的双向通信协议，它提供了可靠的数据传输服务，并且可以在连接建立后保持连接状态，实现双向通信。而HTTP协议是一种基于TCP协议的应用层协议，它使用请求-响应模式的连接方式，客户端发送请求，服务器返回响应。每个请求-响应之间都是一个新的TCP连接，连接建立后传输数据，然后断开连接。

因此，虽然HTTP协议基于TCP协议，但是它并不是一种持久化的双向通信协议，而是一种请求-响应模式的连接方式。在HTTP协议中，每个请求和响应之间都需要重新建立连接，这样会导致TCP连接频繁地建立和断开，对网络资源的消耗较大。为了解决这个问题，后来的Web开发中出现了一些基于TCP的长连接技术，如WebSocket等，用于实现持久化的双向通信。

WebSocket相关的面试问题：

1.  什么是WebSocket协议？它与HTTP协议有什么区别？

    -   WebSocket是一种基于HTTP协议的网络通信协议，可以实现客户端和服务器之间的双向实时通信。与HTTP协议不同的是，WebSocket协议建立的连接是持久化的，在建立连接后，客户端和服务器可以随时互相发送数据，而不需要每次都建立新的连接。

    -   最大区别：连接方式不同：HTTP协议是一种请求-响应模式的连接方式，每次请求都需要建立一次连接；而WebSocket协议建立的连接是持久化的，客户端和服务器之间可以随时互相发送数据。

2.  在Android应用程序中如何使用WebSocket实现实时通信和数据传输？

    在Android应用程序中，可以使用Java语言提供的WebSocket API或者第三方WebSocket库实现WebSocket的实时通信和数据传输。下面是一个基本的Android应用程序使用WebSocket的示例：

    1.  添加WebSocket库依赖

        在应用程序的build.gradle文件中添加WebSocket库依赖，比如OkHttp库提供的WebSocket支持：

        ```groovy
        implementation 'com.squareup.okhttp3:okhttp:x.x.x'
        ```

    2.  创建WebSocket对象

        在代码中创建WebSocket对象，并设置WebSocket连接的回调函数：

        ```java
        private WebSocket mWebSocket;
        
        private void connectWebSocket() {
            String url = "ws://example.com/socket";
        
            OkHttpClient client = new OkHttpClient.Builder().build();
        
            Request request = new Request.Builder()
                    .url(url)
                    .build();
        
            mWebSocket = client.newWebSocket(request, new WebSocketListener() {
                @Override
                public void onOpen(WebSocket webSocket, Response response) {
                    // 连接成功回调
                }
        
                @Override
                public void onMessage(WebSocket webSocket, String text) {
                    // 接收消息回调
                }
        
                @Override
                public void onClosing(WebSocket webSocket, int code, String reason) {
                    // 关闭连接回调
                }
        
                @Override
                public void onFailure(WebSocket webSocket, Throwable t, Response response) {
                    // 连接失败回调
                }
            });
        }
        ```

    3.  发送和接收消息

        使用WebSocket对象发送和接收消息：

        ```java
        private void sendMessage(String message) {
            mWebSocket.send(message);
        }
        
        private void closeWebSocket() {
            mWebSocket.close(1000, null);
        }
        ```

    4.  在AndroidManifest.xml中添加网络权限

        ```xml
        <uses-permission android:name="android.permission.INTERNET" />
        ```

3.  WebSocket协议的通信过程是怎样的？可以说一下具体的握手过程吗？

    

4.  WebSocket和HTTP协议有什么区别？它们各自的优缺点是什么？

5.  在Android应用程序开发中，如何保证WebSocket通信的安全性？







































